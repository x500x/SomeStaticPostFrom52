<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1.0"><title>帖子内容</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>hljs.highlightAll();</script><style>*{word-wrap:break-word}body,html{margin:0;padding:0;width:93%;height:100%}.table-container{width:93vw;overflow-x:auto}table{margin:.25em auto;width:100%;max-width:100%;table-layout:auto;overflow:auto;border-spacing:0;border-collapse:collapse}table tr:nth-child(2n){background-color:#f6f8fa}table thead{background-color:#d9e2df}table th{font-weight:600}table tr{border-top:1px solid #c6cbd1}table td,table th{padding:6px 13px;border:1px solid #c6cbd1 text-align:center}pre{background-color:#F8F8F8;border:1px solid #CCCCCC;border-radius:3px;padding:2px;overflow-x:auto;width:100%;box-sizing:border-box}code{font-family:Consolas,Monaco,Andale Mono,monospace;background-color:#f5f5f5}pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{background:#000;color:#f8f8f8}.hljs-comment,.hljs-meta,.hljs-quote{color:#7c7c7c}.hljs-keyword,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#96cbfe}.hljs-attribute,.hljs-selector-id{color:#ffffb6}.hljs-addition,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string{color:#a8ff60}.hljs-subst{color:#daefa3}.hljs-link,.hljs-regexp{color:#e9c062}.hljs-doctag,.hljs-section,.hljs-title,.hljs-type{color:#ffffb6}.hljs-bullet,.hljs-literal,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#c6c5fe}.hljs-deletion,.hljs-number{color:#ff73fd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.container{width:100%;margin:20px auto;padding:20px;border-radius:8px;word-wrap:break-word}.postcontent{width:100%;margin-bottom:20px;border-bottom:3px solid #e0f7ff;padding-bottom:10px;word-wrap:break-word}.postcontent:last-child{border-bottom:none}.postcontent h1{margin:0 0 10px;font-size:24px}.postcontent p{margin:0 0 10px;font-size:16px}.postcontent .author{font-size:14px;color:#555}.postcontent .timestamp{font-size:12px;color:#888}.postcontent blockquote{border-left:4px solid #ccc;padding:5px 10px;margin:10px 0;background:#f9f9f9}.postcontent blockquote cite{display:block;text-align:right;font-size:12px;color:#555}.postcontent img{max-width:100%;height:auto;margin:10px 0}.postcontent table{width:100%;border-collapse:collapse;margin:10px 0}.postcontent table th,.postcontent table td{border:1px solid #ddd;padding:8px;text-align:left}.postcontent button{background:#007bff;color:#fff;border:none;padding:10px 20px;font-size:16px;cursor:pointer;border-radius:5px}.postcontent button:hover{background:#0056b3}.comment-container{width:90%;margin:20px auto;border:1px solid #f0f0f0;padding:20px;border-radius:5px;font-family:Arial,sans-serif}.comment-header{background-color:#fff7e6;padding:10px;border-left:5px solid #ff5722;margin:-20px -20px 20px;border-radius:5px 5px 0 0;font-weight:bold}.comment-body{margin-top:10px}.comment-author{font-size:18px;color:#333}.comment-text{font-size:16px;color:#555}.comment-time{text-align:right;color:#999;margin-top:10px}</style><div id=zxsq-markdown-code-tools style=display:none;><span class=show>显示代码</span><span class=hide>隐藏代码</span><span class=copy>复制代码</span><span class=copysucc style=display:none>代码已复制到剪贴板</span></div><script>(function(){function n(n,t=1500){var e=document.createElement("div");e.style.position="fixed",e.style.top="20px",e.style.left="50%",e.style.transform="translateX(-50%)",e.style.padding="10px",e.style.backgroundColor="rgba(0, 0, 0, 0.7)",e.style.color="white",e.style.borderRadius="5px",e.style.zIndex="10000",e.innerHTML=n,document.body.appendChild(e),setTimeout(()=>{document.body.removeChild(e)},t)}function t(t,e){var o=document.createElement("textarea");o.value=t,o.style.position="fixed",o.style.opacity="0",document.body.appendChild(o),o.select();try{document.execCommand("copy")&&n(e)}catch(t){console.error("Failed to copy",t)}document.body.removeChild(o)}function e(){var e=document.getElementById("zxsq-markdown-code-tools"),o=e.querySelector(".show").innerText,c=e.querySelector(".hide").innerText,d=e.querySelector(".copy").innerText,i=e.querySelector(".copysucc").innerText;document.querySelectorAll("pre").forEach(e=>{if("hideCode"===e.firstChild.className||"CopyMyCode"===e.firstChild.className||"showCode"===e.firstChild.className)return;var r=document.createElement("div");r.style.display="flex",r.style.justifyContent="flex-start",r.style.alignItems="center",r.style.marginBottom="10px";var a=document.createElement("em");a.className="CopyMyCode",a.style="cursor:pointer;font-size:12px;color:#369 !important;margin-right:10px;",a.innerText=d,r.appendChild(a),a.onclick=function(){t(this.parentElement.parentElement.lastChild.innerText,i)};var s=document.createElement("em");s.className="hideCode",s.style="cursor:pointer;font-size:12px;color:#369 !important;",s.innerText=c,r.appendChild(s),s.onclick=function(){var n=this.parentElement.parentElement.lastChild;"hideCode"===this.className?(n.style.display="none",this.className="showCode",this.innerText=o):(n.style.display="block",this.className="hideCode",this.innerText=c)},e.insertBefore(r,e.firstChild)})}
window.addEventListener("load",e)})();</script></head><body><div class=container><p>原帖地址:https://www.52pojie.cn/thread-2052009-1-1.html</p><div class=postcontent><h1>楼主</h1><div class=author>hrh123</div><div class=timestamp>2025-8-8 19:17</div><i class=pstatus> 本帖最后由 hrh123 于 2025-8-9 10:29 编辑 </i><br><h2 id=53630033_python实现的机器码生成器>Python实现的机器码生成器</h2><h3 id=53630033_前言>前言</h3><p>制作软件的时候肯定会有要求实现机器码，也就是每台机器生成一个唯一的ID。论坛里大佬们逆向的时候也肯定遇到很多软件是要通过机器码来发放注册码的吧。</p><p>我最近遇到了类似的需求，一开始先百度了下，找到了个第三方库<code>py-machineid</code>，但是看了一下发现实现的策略还是比较不完整，且输出格式也不符合我的意思（当然应付正常情况肯定是足够了）。</p><p>于是我到Github上找了一下，其中Star数最高的库是<a href=https://github.com/denisbrodbeck/machineid rel="nofollow noopener">https://github.com/denisbrodbeck/machineid</a>，是由Go语言实现的，我呢就大致参考了ta的思路，也就是将各个平台分开考虑，然后最后统一格式。</p><p>其中为了方便维护，我用了<em>基类</em>这个技巧，这样添加新的策略的时候就只要创建一个新的方法而无需修改核心组件。</p><p>以及为了减少重复调用，我使用了缓存，在没有命中缓存时才会调用方法并且将最终的ID存入缓存。</p><p>（写的这么面向对象是因为有一些功能比如缓存处理之前写过，而且本来整个程序是模块化的设计，为了发出来方便才整合到单文件里的）</p><h3 id=53630033_使用方法>使用方法</h3><p>该程序主要提供了<code>id()</code>和<code>protected_id()</code>两个函数作接口（实际上这俩的区别就是后者app_id是必须的参数，实现方法上其实是一样的，因为当时这部分架构参考了前面提到的<code>py_machineid</code>这个库，但是我的代码封装的比较好所以其实没必要）</p><h3 id=53630033_test.py>test.py</h3><p>由于该程序的特殊性，肯定是不可能把各个平台和策略测试到位的，我用了Github工作流测试了支持的4个平台（Windows，Linux，MacOS和FreeBSD）（Python版本1.13），应该运行还是没问题的，出现bug了可以运行这个测试文件（把主程序改名成main.py并放到和这个文件同目录），然后把生成的报告发给我。</p><pre><code class=language-python>import sys
import os
import json
import time
import hashlib

sys.stdout.reconfigure(encoding='utf-8')

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from main import (
    MachineIDGenerator,
    id,
    protected_id,
    MachineIDError,
    MachineIDNotFound,
    PlatformNotSupported,
    validate_machine_id,
    format_id,
    CacheManager,
)

def test_basic_functionality():
    print("=== 基本功能测试 ===")

    try:
        machine_id = id()
        print(f"机器ID: {machine_id}")
        print(f"ID长度: {len(machine_id)}")
        print(f"ID有效性: {validate_machine_id(machine_id)}")

        protected = protected_id("test_app")
        print(f"受保护ID: {protected}")
        print(f"受保护ID长度: {len(protected)}")

        return True

    except Exception as e:
        print(f"基本功能测试失败: {e}")
        return False

def test_strategies():
    print("\n=== 策略测试 ===")

    generator = MachineIDGenerator()
    strategies = ["auto", "system", "hardware", "hybrid"]
    results = {}

    for strategy in strategies:
        try:
            start_time = time.time()
            machine_id = generator.generate(strategy=strategy)
            end_time = time.time()

            results[strategy] = {
                "id": machine_id,
                "time": end_time - start_time,
                "valid": validate_machine_id(machine_id),
            }

            print(
                f"{strategy:8} | {machine_id[:32]}... | {end_time - start_time:.3f}s | {'✓' if results[strategy]['valid'] else '✗'}"
            )

        except Exception as e:
            print(f"{strategy:8} | 失败: {e}")
            results[strategy] = {"error": str(e)}

    success_count = sum(
        1 for r in results.values() if isinstance(r, dict) and r.get("valid", False)
    )
    return success_count &gt; 0

def test_formats():
    print("\n=== 格式测试 ===")

    try:
        machine_id = id()
        formats = ["raw", "uuid", "md5", "sha256"]

        for fmt in formats:
            formatted = format_id(machine_id, fmt)
            print(f"{fmt:6} | {formatted}")

        return True

    except Exception as e:
        print(f"格式测试失败: {e}")
        return False

def test_caching():
    print("\n=== 缓存测试 ===")

    try:
        generator = MachineIDGenerator()

        generator.clear_cache()

        start_time = time.time()
        id1 = generator.generate(strategy="auto", format_type="raw")
        time1 = time.time() - start_time

        start_time = time.time()
        id2 = generator.generate(strategy="auto", format_type="raw")
        time2 = time.time() - start_time

        print(f"无缓存: {time1:.4f}s")
        print(f"缓存命中: {time2:.4f}s")
        print(f"ID一致性: {id1 == id2}")

        stats = generator.get_cache_stats()
        print(f"缓存统计: {json.dumps(stats, indent=2, ensure_ascii=False)}")

        generator.clear_cache()
        cleared_stats = generator.get_cache_stats()
        print(f"清除缓存后条目数: {cleared_stats.get('memory_entries', 'N/A')}")

        return True

    except Exception as e:
        print(f"缓存测试失败: {e}")
        return False

def test_configuration():
    print("\n=== 配置管理测试 ===")

    try:
        custom_config = {
            "strategy": "system",
            "format": "sha256",
            "cache": {"enabled": True, "ttl": 1800, "file_cache": False},
            "security": {"protected": True, "app_id": "test_app"},
        }

        generator = MachineIDGenerator(custom_config)

        machine_id = generator.generate()
        print(f"自定义配置生成ID: {machine_id[:32]}...")
        print(f"ID长度: {len(machine_id)}")

        return True

    except Exception as e:
        print(f"配置管理测试失败: {e}")
        return False

def test_error_handling():
    print("\n=== 错误处理测试 ===")

    try:
        generator = MachineIDGenerator({"fallback": {"enabled": False}})
        try:
            generator.generate(strategy="invalid")
            print("错误: 应该抛出异常")
            return False
        except ValueError:
            print("✓ 无效策略正确抛出异常")
        except Exception as e:
            print(f"抛出了错误类型的异常: {type(e)} - {e}")
            return False

        try:
            format_id("test", "invalid_format")
            print("错误: 应该抛出异常")
            return False
        except ValueError:
            print("✓ 无效格式正确抛出异常")
        except Exception as e:
            print(f"抛出了错误类型的异常: {type(e)} - {e}")
            return False

        return True

    except Exception as e:
        print(f"错误处理测试失败: {e}")
        return False

def test_protected_ids():
    print("\n=== 受保护ID测试 ===")

    try:
        app_id = "test_application"

        protected1 = protected_id(app_id, strategy="auto")
        print(f"函数接口生成的受保护ID: {protected1}")

        generator = MachineIDGenerator()
        protected2 = generator.generate(
            strategy="auto", format_type="raw", app_id=app_id
        )
        print(f"类接口生成的受保护ID: {protected2}")

        print(f"两种方式结果一致: {protected1 == protected2}")

        print(f"受保护ID长度: {len(protected1)} (应为64)")

        return len(protected1) == 64

    except Exception as e:
        print(f"受保护ID测试失败: {e}")
        return False

def test_cache_manager():
    print("\n=== 缓存管理器测试 ===")

    try:
        cache_config = {
            "enabled": True,
            "ttl": 2,
            "file_cache": False,
            "max_entries": 5,
        }
        cache = CacheManager(cache_config)

        cache.set("test_key", "test_value")
        value = cache.get("test_key")
        print(f"缓存读写测试: {value == 'test_value'}")

        cache.delete("test_key")
        value = cache.get("test_key")
        print(f"缓存删除测试: {value is None}")

        cache.set("expiring_key", "expiring_value")
        time.sleep(3)
        value = cache.get("expiring_key")
        print(f"缓存过期测试: {value is None}")

        cache.clear()
        stats = cache.get_stats()
        print(f"缓存清理后条目数: {stats.get('memory_entries', 'N/A')}")

        return True

    except Exception as e:
        print(f"缓存管理器测试失败: {e}")
        return False

def test_format_functions():
    print("\n=== 格式化函数测试 ===")

    try:
        test_id = "abcd-1234-ef56-7890"

        raw = format_id(test_id, "raw")
        uuid_fmt = format_id(test_id, "uuid")
        md5_fmt = format_id(test_id, "md5")
        sha256_fmt = format_id(test_id, "sha256")

        print(f"原始: {raw}")
        print(f"UUID: {uuid_fmt}")
        print(f"MD5:  {md5_fmt}")
        print(f"SHA256: {sha256_fmt[:32]}...")

        print(f"UUID长度: {len(uuid_fmt)} (应为36)")
        print(f"MD5长度: {len(md5_fmt)} (应为32)")
        print(f"SHA256长度: {len(sha256_fmt)} (应为64)")

        return True

    except Exception as e:
        print(f"格式化函数测试失败: {e}")
        return False

def test_validation_function():
    print("\n=== 验证函数测试 ===")

    try:
        valid_ids = [
            "abcd1234ef567890",
            "a1b2c3d4-e5f6-7890-1234-567890abcdef",
            hashlib.sha256(b"test").hexdigest(),
        ]

        invalid_ids = [
            "",
            "   ",
            "unknown",
            "null",
            "default",
            "0000",
        ]

        print("有效ID测试:")
        for vid in valid_ids:
            result = validate_machine_id(vid)
            print(f"  {vid[:20]:20} ... {result}")

        print("无效ID测试:")
        for iid in invalid_ids:
            result = validate_machine_id(iid)
            print(f"  {repr(iid):20} ... {result}")

        valid_results = all(validate_machine_id(vid) for vid in valid_ids)
        invalid_results = all(not validate_machine_id(iid) for iid in invalid_ids)

        print(f"有效ID测试通过: {valid_results}")
        print(f"无效ID测试通过: {invalid_results}")

        return valid_results and invalid_results

    except Exception as e:
        print(f"验证函数测试失败: {e}")
        return False

def run_all_tests():
    print("机器标识符生成器综合测试")
    print("=" * 50)

    tests = [
        ("基本功能", test_basic_functionality),
        ("策略测试", test_strategies),
        ("格式测试", test_formats),
        ("缓存测试", test_caching),
        ("配置管理", test_configuration),
        ("错误处理", test_error_handling),
        ("受保护ID", test_protected_ids),
        ("缓存管理器", test_cache_manager),
        ("格式化函数", test_format_functions),
        ("验证函数", test_validation_function),
    ]

    results = {}
    for test_name, test_func in tests:
        try:
            print(f"\n开始测试: {test_name}")
            result = test_func()
            results[test_name] = result
            print(f"{test_name}测试结果: {'✓ 通过' if result else '✗ 失败'}")
        except Exception as e:
            print(f"{test_name}测试出现异常: {e}")
            results[test_name] = False

    print("\n" + "=" * 50)
    print("测试结果汇总:")
    for test_name, result in results.items():
        status = "✓ 通过" if result else "✗ 失败"
        print(f"  {test_name:15} | {status}")

    passed = sum(1 for r in results.values() if r)
    total = len(results)
    print(f"\n总计: {passed}/{total} 个测试通过")

    return passed == total

if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)</code></pre><h3 id=53630033_主程序>主程序</h3><p>以下是主程序，<strong>未经许可禁止转载</strong></p><pre><code class=language-python>import hashlib
import hmac
import json
import os
import platform
import re
import subprocess
import tempfile
import time
import uuid
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any

class MachineIDError(Exception):

    def __init__(
        self,
        message: str,
        error_code: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message)
        self.message = message
        self.error_code = error_code or "MACHINE_ID_ERROR"
        self.context = context or {}
        self.timestamp = time.time()

    def __str__(self) -&gt; str:
        return f"[{self.error_code}] {self.message}"

    def __repr__(self) -&gt; str:
        return f"{self.__class__.__name__}(message='{self.message}', error_code='{self.error_code}')"

    def to_dict(self) -&gt; Dict[str, Any]:
        return {
            "error_type": self.__class__.__name__,
            "message": self.message,
            "error_code": self.error_code,
            "context": self.context,
            "timestamp": self.timestamp,
        }

class MachineIDNotFound(MachineIDError):

    def __init__(
        self,
        message: str = "无法获取机器标识符",
        platform: Optional[str] = None,
        attempted_methods: Optional[List[str]] = None,
        context: Optional[Dict[str, Any]] = None,
    ):

        error_context = context or {}
        if platform:
            error_context["platform"] = platform
        if attempted_methods:
            error_context["attempted_methods"] = attempted_methods

        super().__init__(message, "MACHINE_ID_NOT_FOUND", error_context)
        self.platform = platform
        self.attempted_methods = attempted_methods or []

    def add_attempted_method(self, method: str) -&gt; None:
        if method not in self.attempted_methods:
            self.attempted_methods.append(method)
            self.context["attempted_methods"] = self.attempted_methods

class PlatformNotSupported(MachineIDError):

    def __init__(
        self,
        message: str = "当前平台不受支持",
        platform: Optional[str] = None,
        supported_platforms: Optional[List[str]] = None,
        context: Optional[Dict[str, Any]] = None,
    ):

        error_context = context or {}
        if platform:
            error_context["current_platform"] = platform
        if supported_platforms:
            error_context["supported_platforms"] = supported_platforms

        super().__init__(message, "PLATFORM_NOT_SUPPORTED", error_context)
        self.platform = platform
        self.supported_platforms = supported_platforms or [
            "Windows",
            "Linux",
            "macOS",
            "BSD",
        ]

    def get_suggestion(self) -&gt; str:
        if self.supported_platforms:
            platforms_str = ", ".join(self.supported_platforms)
            return f"请在以下支持的平台上运行: {platforms_str}"
        return "请检查平台兼容性"

class HardwareInfoError(MachineIDError):

    def __init__(
        self,
        message: str = "无法获取硬件信息",
        hardware_type: Optional[str] = None,
        command: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None,
    ):

        error_context = context or {}
        if hardware_type:
            error_context["hardware_type"] = hardware_type
        if command:
            error_context["failed_command"] = command

        super().__init__(message, "HARDWARE_INFO_ERROR", error_context)
        self.hardware_type = hardware_type
        self.command = command

class CacheError(MachineIDError):
    def __init__(
        self,
        message: str = "缓存操作失败",
        operation: Optional[str] = None,
        cache_type: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None,
    ):

        error_context = context or {}
        if operation:
            error_context["operation"] = operation
        if cache_type:
            error_context["cache_type"] = cache_type

        super().__init__(message, "CACHE_ERROR", error_context)
        self.operation = operation
        self.cache_type = cache_type

def protect_id(app_id: str, machine_id: str) -&gt; str:
    mac = hmac.new(machine_id.encode("utf-8"), app_id.encode("utf-8"), hashlib.sha256)
    return mac.hexdigest()

def format_id(machine_id: str, format_type: str = "raw") -&gt; str:
    if format_type == "raw":
        return sanitize_id(machine_id)
    elif format_type == "uuid":
        return format_as_uuid(machine_id)
    elif format_type == "md5":
        return hashlib.md5(machine_id.encode("utf-8")).hexdigest()
    elif format_type == "sha256":
        return hashlib.sha256(machine_id.encode("utf-8")).hexdigest()
    else:
        raise ValueError(f"不支持的格式类型: {format_type}")

def sanitize_id(machine_id: str) -&gt; str:
    cleaned = re.sub(r"[\x00-\x1f\x7f-\x9f\s]", "", machine_id)
    return cleaned.strip().upper()

def format_as_uuid(machine_id: str) -&gt; str:
    if is_valid_uuid(machine_id):
        return machine_id.upper()

    hash_obj = hashlib.md5(machine_id.encode("utf-8"))
    hex_str = hash_obj.hexdigest()

    return f"{hex_str[:8]}-{hex_str[8:12]}-{hex_str[12:16]}-{hex_str[16:20]}-{hex_str[20:32]}".upper()

def is_valid_uuid(test_string: str) -&gt; bool:
    try:
        uuid.UUID(test_string)
        return True
    except ValueError:
        return False

def validate_machine_id(machine_id: str) -&gt; bool:
    if not machine_id or len(machine_id.strip()) == 0:
        return False

    cleaned = sanitize_id(machine_id)
    if len(cleaned) &lt; 8:
        return False

    invalid_patterns = ["unknown", "default", "none", "null", "0000", "ffff"]
    cleaned_lower = cleaned.lower()

    for pattern in invalid_patterns:
        if pattern in cleaned_lower:
            return False

    return True

class CacheManager:
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.enabled = self.config.get("enabled", True)
        self.ttl = self.config.get("ttl", 3600)
        self.file_cache_enabled = self.config.get("file_cache", False)
        self.cache_dir = self.config.get("cache_dir") or tempfile.gettempdir()
        self.max_entries = self.config.get("max_entries", 100)

        self._memory_cache: Dict[str, Dict[str, Any]] = {}
        self._cache_file = os.path.join(self.cache_dir, "machine_id_cache.json")

        if self.file_cache_enabled:
            self._load_file_cache()

    def get(self, key: str) -&gt; Optional[str]:
        if not self.enabled:
            return None

        value = self._get_from_memory(key)
        if value is not None:
            return value

        if self.file_cache_enabled:
            value = self._get_from_file(key)
            if value is not None:
                self._set_to_memory(key, value)
                return value

        return None

    def set(self, key: str, value: str) -&gt; None:
        if not self.enabled:
            return

        try:
            self._set_to_memory(key, value)

            if self.file_cache_enabled:
                self._set_to_file(key, value)

        except Exception:
            pass

    def delete(self, key: str) -&gt; None:
        if not self.enabled:
            return

        if key in self._memory_cache:
            del self._memory_cache[key]

        if self.file_cache_enabled:
            self._delete_from_file(key)

    def clear(self) -&gt; None:
        if not self.enabled:
            return

        self._memory_cache.clear()

        if self.file_cache_enabled:
            try:
                if os.path.exists(self._cache_file):
                    os.remove(self._cache_file)
            except OSError:
                pass

    def cleanup_expired(self) -&gt; None:
        if not self.enabled:
            return

        current_time = time.time()
        expired_keys = []

        for key, cache_item in self._memory_cache.items():
            if current_time - cache_item["timestamp"] &gt; self.ttl:
                expired_keys.append(key)

        for key in expired_keys:
            del self._memory_cache[key]

        if self.file_cache_enabled:
            self._cleanup_file_cache()

    def get_stats(self) -&gt; Dict[str, Any]:
        stats = {
            "enabled": self.enabled,
            "memory_entries": len(self._memory_cache),
            "ttl": self.ttl,
            "file_cache_enabled": self.file_cache_enabled,
            "max_entries": self.max_entries,
        }

        if self.file_cache_enabled:
            stats["cache_file"] = self._cache_file
            stats["cache_file_exists"] = os.path.exists(self._cache_file)

            if stats["cache_file_exists"]:
                try:
                    stats["cache_file_size"] = os.path.getsize(self._cache_file)
                except OSError:
                    stats["cache_file_size"] = -1

        return stats

    def _get_from_memory(self, key: str) -&gt; Optional[str]:
        if key not in self._memory_cache:
            return None

        cache_item = self._memory_cache[key]
        current_time = time.time()

        if current_time - cache_item["timestamp"] &gt; self.ttl:
            del self._memory_cache[key]
            return None

        return cache_item["value"]

    def _set_to_memory(self, key: str, value: str) -&gt; None:
        if len(self._memory_cache) &gt;= self.max_entries:
            oldest_key = min(
                self._memory_cache.keys(),
                key=lambda k: self._memory_cache[k]["timestamp"],
            )
            del self._memory_cache[oldest_key]

        self._memory_cache[key] = {"value": value, "timestamp": time.time()}

    def _get_from_file(self, key: str) -&gt; Optional[str]:
        try:
            if not os.path.exists(self._cache_file):
                return None

            with open(self._cache_file, "r", encoding="utf-8") as f:
                cache_data = json.load(f)

            if key not in cache_data:
                return None

            cache_item = cache_data[key]
            current_time = time.time()

            if current_time - cache_item["timestamp"] &gt; self.ttl:
                return None

            return cache_item["value"]

        except (IOError, json.JSONDecodeError, KeyError):
            return None

    def _set_to_file(self, key: str, value: str) -&gt; None:
        try:
            os.makedirs(self.cache_dir, exist_ok=True)

            cache_data = {}
            if os.path.exists(self._cache_file):
                try:
                    with open(self._cache_file, "r", encoding="utf-8") as f:
                        cache_data = json.load(f)
                except (json.JSONDecodeError, IOError):
                    cache_data = {}

            cache_data[key] = {"value": value, "timestamp": time.time()}

            with open(self._cache_file, "w", encoding="utf-8") as f:
                json.dump(cache_data, f, indent=2)

        except (IOError, OSError):
            pass

    def _delete_from_file(self, key: str) -&gt; None:
        try:
            if not os.path.exists(self._cache_file):
                return

            with open(self._cache_file, "r", encoding="utf-8") as f:
                cache_data = json.load(f)

            if key in cache_data:
                del cache_data[key]

                with open(self._cache_file, "w", encoding="utf-8") as f:
                    json.dump(cache_data, f, indent=2)

        except (IOError, json.JSONDecodeError):
            pass

    def _load_file_cache(self) -&gt; None:
        try:
            if not os.path.exists(self._cache_file):
                return

            with open(self._cache_file, "r", encoding="utf-8") as f:
                cache_data = json.load(f)

            current_time = time.time()

            for key, cache_item in cache_data.items():
                if current_time - cache_item["timestamp"] &lt;= self.ttl:
                    if len(self._memory_cache) &lt; self.max_entries:
                        self._memory_cache[key] = cache_item

        except (IOError, json.JSONDecodeError):
            pass

    def _cleanup_file_cache(self) -&gt; None:
        try:
            if not os.path.exists(self._cache_file):
                return

            with open(self._cache_file, "r", encoding="utf-8") as f:
                cache_data = json.load(f)

            current_time = time.time()
            cleaned_data = {}

            for key, cache_item in cache_data.items():
                if current_time - cache_item["timestamp"] &lt;= self.ttl:
                    cleaned_data[key] = cache_item

            if len(cleaned_data) != len(cache_data):
                with open(self._cache_file, "w", encoding="utf-8") as f:
                    json.dump(cleaned_data, f, indent=2)

        except (IOError, json.JSONDecodeError):
            pass

class BasePlatformAdapter(ABC):
    def __init__(self):
        self.system_info = self._get_system_info()

    @abstractmethod
    def get_system_id(self) -&gt; str:
        raise NotImplementedError("子类必须实现 get_system_id 方法")

    def get_hardware_id(self) -&gt; str:
        hardware_info = self._collect_hardware_info()
        combined_info = "|".join(
            [
                hardware_info.get("motherboard_serial", "unknown"),
                hardware_info.get("cpu_id", "unknown"),
                hardware_info.get("mac_address", "unknown"),
                hardware_info.get("disk_serial", "unknown"),
                self.system_info.get("system", "unknown"),
                self.system_info.get("machine", "unknown"),
            ]
        )

        return hashlib.sha256(combined_info.encode("utf-8")).hexdigest()

    def get_hybrid_id(self) -&gt; str:
        try:
            system_id = self.get_system_id()
            if validate_machine_id(system_id):
                return system_id
        except Exception:
            pass

        return self.get_hardware_id()

    def _collect_hardware_info(self) -&gt; Dict[str, str]:
        info = {}

        try:
            info["motherboard_serial"] = self._get_motherboard_serial()
        except Exception:
            info["motherboard_serial"] = "unknown"

        try:
            info["cpu_id"] = self._get_cpu_id()
        except Exception:
            info["cpu_id"] = "unknown"

        try:
            info["mac_address"] = self._get_mac_address()
        except Exception:
            info["mac_address"] = "unknown"

        try:
            info["disk_serial"] = self._get_disk_serial()
        except Exception:
            info["disk_serial"] = "unknown"

        return info

    def _get_system_info(self) -&gt; Dict[str, str]:
        return {
            "system": platform.system(),
            "release": platform.release(),
            "version": platform.version(),
            "machine": platform.machine(),
            "processor": platform.processor(),
        }

    def _get_mac_address(self) -&gt; str:
        mac = uuid.getnode()
        return ":".join(
            ["{:02x}".format((mac &gt;&gt; ele) &amp; 0xFF) for ele in range(0, 8 * 6, 8)][::-1]
        )

    @abstractmethod
    def _get_motherboard_serial(self) -&gt; str:
        raise NotImplementedError("子类必须实现 _get_motherboard_serial 方法")

    @abstractmethod
    def _get_cpu_id(self) -&gt; str:
        raise NotImplementedError("子类必须实现 _get_cpu_id 方法")

    def _get_disk_serial(self) -&gt; str:
        return "unknown"

    def _execute_command(self, command: str, shell: bool = True) -&gt; Optional[str]:
        try:
            result = subprocess.run(
                command,
                shell=shell,
                capture_output=True,
                text=True,
                timeout=10,
                check=True,
            )
            return result.stdout.strip()
        except (subprocess.SubprocessError, subprocess.TimeoutExpired):
            return None

    def _read_file(self, filepath: str) -&gt; Optional[str]:
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                return f.read().strip()
        except (IOError, OSError):
            return None

    def get_capabilities(self) -&gt; Dict[str, Any]:
        return {
            "platform": self.system_info.get("system", "unknown"),
            "supports_system_id": True,
            "supports_hardware_id": True,
            "supports_hybrid_id": True,
            "hardware_sources": [
                "motherboard_serial",
                "cpu_id",
                "mac_address",
                "disk_serial",
            ],
        }

class WindowsPlatformAdapter(BasePlatformAdapter):
    def get_system_id(self) -&gt; str:
        machine_id = self._get_machine_guid_from_registry()
        if machine_id:
            return sanitize_id(machine_id)

        machine_id = self._get_machine_guid_from_powershell()
        if machine_id:
            return sanitize_id(machine_id)

        machine_id = self._get_machine_guid_from_wmic()
        if machine_id:
            return sanitize_id(machine_id)

        raise MachineIDNotFound("无法获取Windows MachineGuid")

    def _get_machine_guid_from_registry(self) -&gt; Optional[str]:
        try:
            import winreg

            key_path = r"SOFTWARE\Microsoft\Cryptography"

            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path) as key:
                machine_guid, _ = winreg.QueryValueEx(key, "MachineGuid")
                return machine_guid

        except ImportError:
            return None
        except (OSError, FileNotFoundError):
            return None

    def _get_machine_guid_from_powershell(self) -&gt; Optional[str]:
        command = 'powershell.exe -ExecutionPolicy bypass -command "(Get-CimInstance -Class Win32_ComputerSystemProduct).UUID"'
        result = self._execute_command(command)

        if result and result.lower() not in ["", "null", "none"]:
            return result
        return None

    def _get_machine_guid_from_wmic(self) -&gt; Optional[str]:
        command = "wmic csproduct get uuid"
        result = self._execute_command(command)

        if result:
            lines = result.split("\n")
            for line in lines:
                line = line.strip()
                if line and line.lower() not in ["uuid", "", "null", "none"]:
                    return line
        return None

    def _get_motherboard_serial(self) -&gt; str:
        command = "wmic baseboard get serialnumber"
        result = self._execute_command(command)

        if result:
            lines = result.split("\n")
            for line in lines:
                line = line.strip()
                if line and line.lower() not in ["serialnumber", "", "null", "none"]:
                    return line

        command = 'powershell.exe -command "(Get-CimInstance -Class Win32_BaseBoard).SerialNumber"'
        result = self._execute_command(command)

        if result and result.lower() not in ["", "null", "none"]:
            return result

        return "unknown"

    def _get_cpu_id(self) -&gt; str:
        command = "wmic cpu get processorid"
        result = self._execute_command(command)

        if result:
            lines = result.split("\n")
            for line in lines:
                line = line.strip()
                if line and line.lower() not in ["processorid", "", "null", "none"]:
                    return line

        command = 'powershell.exe -command "(Get-CimInstance -Class Win32_Processor).ProcessorId"'
        result = self._execute_command(command)

        if result and result.lower() not in ["", "null", "none"]:
            return result

        command = "wmic cpu get name"
        result = self._execute_command(command)

        if result:
            lines = result.split("\n")
            for line in lines:
                line = line.strip()
                if line and line.lower() not in ["name", "", "null", "none"]:
                    return line

        return self.system_info.get("processor", "unknown")

    def _get_disk_serial(self) -&gt; str:
        command = 'wmic logicaldisk where caption="C:" get volumeserialnumber'
        result = self._execute_command(command)

        if result:
            lines = result.split("\n")
            for line in lines:
                line = line.strip()
                if line and line.lower() not in [
                    "volumeserialnumber",
                    "",
                    "null",
                    "none",
                ]:
                    return line

        return "unknown"

class LinuxPlatformAdapter(BasePlatformAdapter):
    MACHINE_ID_PATHS = ["/var/lib/dbus/machine-id", "/etc/machine-id"]

    def get_system_id(self) -&gt; str:
        for path in self.MACHINE_ID_PATHS:
            machine_id = self._read_file(path)
            if machine_id and len(machine_id.strip()) &gt; 0:
                return sanitize_id(machine_id)

        container_id = self._get_container_id()
        if container_id:
            return sanitize_id(container_id)

        wsl_id = self._get_wsl_id()
        if wsl_id:
            return sanitize_id(wsl_id)

        raise MachineIDNotFound("无法获取Linux machine-id")

    def _get_container_id(self) -&gt; Optional[str]:
        docker_id = self._get_docker_id()
        if docker_id:
            return docker_id

        return None

    def _get_docker_id(self) -&gt; Optional[str]:
        cgroup_content = self._read_file("/proc/self/cgroup")
        if cgroup_content and "docker" in cgroup_content:
            command = "head -1 /proc/self/cgroup | cut -d/ -f3"
            result = self._execute_command(command)
            if result and len(result) &gt;= 12:
                return result

        mountinfo_content = self._read_file("/proc/self/mountinfo")
        if mountinfo_content and "docker" in mountinfo_content:
            command = "grep -oP '(?&lt;=docker/containers/)([a-f0-9]+)(?=/hostname)' /proc/self/mountinfo"
            result = self._execute_command(command)
            if result:
                return result

        return None

    def _get_wsl_id(self) -&gt; Optional[str]:
        if "microsoft" in self.system_info.get("release", "").lower():
            command = "powershell.exe -ExecutionPolicy bypass -command '(Get-CimInstance -Class Win32_ComputerSystemProduct).UUID'"
            result = self._execute_command(command)
            if result and result.lower() not in ["", "null", "none"]:
                return result

        return None

    def _get_motherboard_serial(self) -&gt; str:
        dmi_serial = self._read_file("/sys/class/dmi/id/board_serial")
        if dmi_serial and dmi_serial.lower() not in [
            "",
            "null",
            "none",
            "not specified",
        ]:
            return dmi_serial

        command = "dmidecode -s baseboard-serial-number"
        result = self._execute_command(command)
        if result and result.lower() not in ["", "null", "none", "not specified"]:
            return result

        alternative_paths = [
            "/sys/class/dmi/id/product_serial",
            "/sys/class/dmi/id/chassis_serial",
        ]

        for path in alternative_paths:
            serial = self._read_file(path)
            if serial and serial.lower() not in ["", "null", "none", "not specified"]:
                return serial

        return "unknown"

    def _get_cpu_id(self) -&gt; str:
        cpuinfo = self._read_file("/proc/cpuinfo")
        if cpuinfo:
            for line in cpuinfo.split("\n"):
                line = line.strip()
                if line.startswith("processor") and ":" in line:
                    continue
                if any(
                    key in line.lower()
                    for key in ["serial", "processor id", "cpu serial"]
                ):
                    if ":" in line:
                        value = line.split(":", 1)[1].strip()
                        if value and value.lower() not in ["", "null", "none"]:
                            return value

        command = "dmidecode -t processor | grep 'ID:'"
        result = self._execute_command(command)
        if result:
            lines = result.split("\n")
            for line in lines:
                if "ID:" in line:
                    cpu_id = line.split("ID:", 1)[1].strip()
                    if cpu_id and cpu_id.lower() not in ["", "null", "none"]:
                        return cpu_id

        if cpuinfo:
            for line in cpuinfo.split("\n"):
                if line.startswith("model name") and ":" in line:
                    model = line.split(":", 1)[1].strip()
                    if model:
                        return model
                    break

        return self.system_info.get("processor", "unknown")

    def _get_disk_serial(self) -&gt; str:
        command = (
            "lsblk -no SERIAL $(df / | tail -1 | awk '{print $1}' | sed 's/[0-9]*$//')"
        )
        result = self._execute_command(command)
        if result and result.lower() not in ["", "null", "none"]:
            return result

        command = "udevadm info --query=property --name=$(df / | tail -1 | awk '{print $1}' | sed 's/[0-9]*$//') | grep ID_SERIAL_SHORT"
        result = self._execute_command(command)
        if result and "=" in result:
            serial = result.split("=", 1)[1].strip()
            if serial and serial.lower() not in ["", "null", "none"]:
                return serial

        try:
            for device in os.listdir("/sys/block"):
                if device.startswith(("sd", "nvme", "hd")):
                    serial_path = f"/sys/block/{device}/device/serial"
                    serial = self._read_file(serial_path)
                    if serial and serial.lower() not in ["", "null", "none"]:
                        return serial
        except (OSError, IOError):
            pass

        return "unknown"

class DarwinPlatformAdapter(BasePlatformAdapter):
    def get_system_id(self) -&gt; str:
        platform_uuid = self._get_platform_uuid_from_ioreg()
        if platform_uuid:
            return sanitize_id(platform_uuid)

        platform_uuid = self._get_platform_uuid_from_system_profiler()
        if platform_uuid:
            return sanitize_id(platform_uuid)

        raise MachineIDNotFound("无法获取macOS IOPlatformUUID")

    def _get_platform_uuid_from_ioreg(self) -&gt; Optional[str]:
        command = "ioreg -rd1 -c IOPlatformExpertDevice"
        result = self._execute_command(command)

        if result:
            return self._extract_platform_uuid(result)

        return None

    def _get_platform_uuid_from_system_profiler(self) -&gt; Optional[str]:
        command = "system_profiler SPHardwareDataType"
        result = self._execute_command(command)

        if result:
            for line in result.split("\n"):
                line = line.strip()
                if "Hardware UUID:" in line or "Platform UUID:" in line:
                    uuid_match = re.search(
                        r"([A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12})",
                        line,
                        re.IGNORECASE,
                    )
                    if uuid_match:
                        return uuid_match.group(1)

        return None

    def _extract_platform_uuid(self, ioreg_output: str) -&gt; Optional[str]:
        for line in ioreg_output.split("\n"):
            if "IOPlatformUUID" in line:
                uuid_match = re.search(
                    r'"([A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12})"',
                    line,
                    re.IGNORECASE,
                )
                if uuid_match:
                    return uuid_match.group(1)

                if "=" in line:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        uuid_candidate = parts[1].strip().strip('"')
                        if re.match(
                            r"^[A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12}$",
                            uuid_candidate,
                            re.IGNORECASE,
                        ):
                            return uuid_candidate

        return None

    def _get_motherboard_serial(self) -&gt; str:
        command = "system_profiler SPHardwareDataType"
        result = self._execute_command(command)

        if result:
            for line in result.split("\n"):
                line = line.strip()
                if "Serial Number:" in line:
                    serial = line.split("Serial Number:", 1)[1].strip()
                    if serial and serial.lower() not in ["", "null", "none"]:
                        return serial

        command = "ioreg -l | grep IOPlatformSerialNumber"
        result = self._execute_command(command)

        if result:
            serial_match = re.search(r'"([^"]+)"', result)
            if serial_match:
                serial = serial_match.group(1)
                if serial and serial.lower() not in ["", "null", "none"]:
                    return serial

        return "unknown"

    def _get_cpu_id(self) -&gt; str:
        command = "system_profiler SPHardwareDataType"
        result = self._execute_command(command)

        if result:
            cpu_info = []
            for line in result.split("\n"):
                line = line.strip()
                if any(
                    key in line
                    for key in [
                        "Processor Name:",
                        "Processor Speed:",
                        "Number of Processors:",
                    ]
                ):
                    cpu_info.append(line)

            if cpu_info:
                return " | ".join(cpu_info)

        command = "sysctl -n machdep.cpu.brand_string"
        result = self._execute_command(command)
        if result:
            return result

        command = "sysctl -n hw.model"
        result = self._execute_command(command)
        if result:
            return result

        return self.system_info.get("processor", "unknown")

    def _get_disk_serial(self) -&gt; str:
        command = "diskutil info / | grep 'Device / Media Name'"
        result = self._execute_command(command)
        if result:
            return result.split(":", 1)[1].strip() if ":" in result else result

        command = "system_profiler SPStorageDataType"
        result = self._execute_command(command)

        if result:
            for line in result.split("\n"):
                line = line.strip()
                if "Serial Number:" in line:
                    serial = line.split("Serial Number:", 1)[1].strip()
                    if serial and serial.lower() not in ["", "null", "none"]:
                        return serial

        command = "ioreg -r -c IOBlockStorageDriver"
        result = self._execute_command(command)

        if result:
            serial_match = re.search(r'"Device Serial Number" = "([^"]+)"', result)
            if serial_match:
                serial = serial_match.group(1)
                if serial and serial.lower() not in ["", "null", "none"]:
                    return serial

        return "unknown"

class BSDPlatformAdapter(BasePlatformAdapter):
    def get_system_id(self) -&gt; str:
        hostid = self._read_file("/etc/hostid")
        if hostid and len(hostid.strip()) &gt; 0:
            return sanitize_id(hostid)

        smbios_uuid = self._get_smbios_uuid()
        if smbios_uuid:
            return sanitize_id(smbios_uuid)

        sysctl_id = self._get_sysctl_machine_id()
        if sysctl_id:
            return sanitize_id(sysctl_id)

        raise MachineIDNotFound("无法获取BSD系统ID")

    def _get_smbios_uuid(self) -&gt; Optional[str]:
        command = "kenv -q smbios.system.uuid"
        result = self._execute_command(command)

        if result and result.lower() not in ["", "null", "none"]:
            return result

        return None

    def _get_sysctl_machine_id(self) -&gt; Optional[str]:
        sysctl_keys = ["kern.hostuuid", "hw.uuid", "machdep.dmi.system-uuid"]

        for key in sysctl_keys:
            command = f"sysctl -n {key}"
            result = self._execute_command(command)
            if result and result.lower() not in ["", "null", "none"]:
                return result

        return None

    def _get_motherboard_serial(self) -&gt; str:
        command = "dmidecode -s baseboard-serial-number"
        result = self._execute_command(command)
        if result and result.lower() not in ["", "null", "none", "not specified"]:
            return result

        command = "kenv -q smbios.planar.serial"
        result = self._execute_command(command)
        if result and result.lower() not in ["", "null", "none"]:
            return result

        command = "sysctl -n hw.serial"
        result = self._execute_command(command)
        if result and result.lower() not in ["", "null", "none"]:
            return result

        return "unknown"

    def _get_cpu_id(self) -&gt; str:
        cpu_info = []

        cpu_keys = ["hw.model", "hw.machine", "hw.ncpu"]

        for key in cpu_keys:
            command = f"sysctl -n {key}"
            result = self._execute_command(command)
            if result:
                cpu_info.append(f"{key}={result}")

        if cpu_info:
            return " | ".join(cpu_info)

        command = "dmesg | grep -i cpu | head -1"
        result = self._execute_command(command)
        if result:
            return result.strip()

        return self.system_info.get("processor", "unknown")

    def _get_disk_serial(self) -&gt; str:
        command = "camcontrol devlist"
        result = self._execute_command(command)
        if result:
            lines = result.split("\n")
            for line in lines:
                if "da0" in line or "ada0" in line:
                    return line.strip()

        command = "diskinfo -v /dev/ada0"
        result = self._execute_command(command)
        if result:
            for line in result.split("\n"):
                if "ident" in line.lower() or "serial" in line.lower():
                    parts = line.split()
                    if len(parts) &gt;= 2:
                        return parts[-1]

        command = "dmesg | grep -i 'serial number' | head -1"
        result = self._execute_command(command)
        if result:
            return result.strip()

        return "unknown"

def get_platform_adapter() -&gt; BasePlatformAdapter:
    system = platform.system().lower()

    if system == "windows":
        return WindowsPlatformAdapter()
    elif system == "linux":
        return LinuxPlatformAdapter()
    elif system == "darwin":
        return DarwinPlatformAdapter()
    elif system in ["freebsd", "openbsd", "netbsd"]:
        return BSDPlatformAdapter()
    else:
        raise PlatformNotSupported(f"不支持的平台: {system}")

class ConfigManager:
    DEFAULT_CONFIG = {
        "strategy": "auto",
        "format": "raw",
        "cache": {
            "enabled": True,
            "ttl": 3600,
            "file_cache": False,
            "cache_dir": tempfile.gettempdir(),
            "max_entries": 100,
        },
        "security": {"protected": False, "app_id": None},
        "fallback": {"enabled": True, "strategies": ["system", "hardware", "hybrid"]},
    }

    def __init__(self, config_file: Optional[str] = None):
        self.config_file = config_file
        self.config = self.DEFAULT_CONFIG.copy()

        if config_file and os.path.exists(config_file):
            self.load_config()

    def load_config(self) -&gt; None:
        if not self.config_file or not os.path.exists(self.config_file):
            return

        try:
            with open(self.config_file, "r", encoding="utf-8") as f:
                user_config = json.load(f)

            self._merge_config(self.config, user_config)

        except (IOError, json.JSONDecodeError):
            pass

    def save_config(self) -&gt; None:
        if not self.config_file:
            return

        try:
            os.makedirs(os.path.dirname(self.config_file), exist_ok=True)

            with open(self.config_file, "w", encoding="utf-8") as f:
                json.dump(self.config, f, indent=2)

        except (IOError, OSError):
            pass

    def get(self, key: str, default: Any = None) -&gt; Any:
        keys = key.split(".")
        value = self.config

        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default

        return value

    def set(self, key: str, value: Any) -&gt; None:
        keys = key.split(".")
        config = self.config

        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]

        config[keys[-1]] = value

    def _merge_config(self, base: dict, user: dict) -&gt; None:
        for key, value in user.items():
            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                self._merge_config(base[key], value)
            else:
                base[key] = value

class MachineIDGenerator:
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config_manager = ConfigManager()
        if config:
            for key, value in config.items():
                self.config_manager.set(key, value)

        self.cache_manager = CacheManager(self.config_manager.get("cache", {}))
        self.platform_adapter = get_platform_adapter()

    def generate(
        self,
        strategy: Optional[str] = None,
        format_type: Optional[str] = None,
        app_id: Optional[str] = None,
    ) -&gt; str:
        strategy = strategy or self.config_manager.get("strategy", "auto")
        format_type = format_type or self.config_manager.get("format", "raw")
        app_id = app_id or self.config_manager.get("security.app_id")

        cache_key = f"{strategy}_{format_type}_{app_id or 'none'}"

        cached_id = self.cache_manager.get(cache_key)
        if cached_id:
            return cached_id

        try:
            machine_id = self._generate_by_strategy(strategy)

            if not validate_machine_id(machine_id):
                if self.config_manager.get("fallback.enabled", True):
                    machine_id = self._generate_with_fallback(strategy)
                else:
                    raise MachineIDNotFound(f"生成的机器ID无效: {machine_id}")

            formatted_id = format_id(machine_id, format_type)

            if app_id:
                formatted_id = protect_id(app_id, formatted_id)

            self.cache_manager.set(cache_key, formatted_id)

            return formatted_id

        except Exception as e:
            if self.config_manager.get("fallback.enabled", True):
                return self._generate_with_fallback(strategy, format_type, app_id)
            else:
                raise e

    def _generate_by_strategy(self, strategy: str) -&gt; str:
        if strategy == "auto":
            return self.platform_adapter.get_hybrid_id()
        elif strategy == "system":
            return self.platform_adapter.get_system_id()
        elif strategy == "hardware":
            return self.platform_adapter.get_hardware_id()
        elif strategy == "hybrid":
            return self.platform_adapter.get_hybrid_id()
        else:
            raise ValueError(f"不支持的策略: {strategy}")

    def _generate_with_fallback(
        self,
        original_strategy: str,
        format_type: Optional[str] = None,
        app_id: Optional[str] = None,
    ) -&gt; str:
        fallback_strategies = self.config_manager.get(
            "fallback.strategies", ["system", "hardware", "hybrid"]
        )

        if original_strategy in fallback_strategies:
            fallback_strategies = [
                s for s in fallback_strategies if s != original_strategy
            ]

        for strategy in fallback_strategies:
            try:
                machine_id = self._generate_by_strategy(strategy)
                if validate_machine_id(machine_id):
                    formatted_id = format_id(machine_id, format_type or "raw")
                    if app_id:
                        formatted_id = protect_id(app_id, formatted_id)
                    return formatted_id
            except Exception:
                continue

        raise MachineIDNotFound("所有策略都无法生成有效的机器ID")

    def get_capabilities(self) -&gt; Dict[str, Any]:
        return self.platform_adapter.get_capabilities()

    def clear_cache(self) -&gt; None:
        self.cache_manager.clear()

    def get_cache_stats(self) -&gt; Dict[str, Any]:
        return self.cache_manager.get_stats()

def id(
    strategy: str = "auto", format_type: str = "raw", app_id: Optional[str] = None
) -&gt; str:
    generator = MachineIDGenerator()
    return generator.generate(strategy=strategy, format_type=format_type, app_id=app_id)

def protected_id(app_id: str, strategy: str = "auto", format_type: str = "raw") -&gt; str:
    generator = MachineIDGenerator()
    return generator.generate(strategy=strategy, format_type=format_type, app_id=app_id)</code></pre><div class=parsedown-markdown-end_FLAG_ZXSQ style=display:none></div></div><div class=postcontent><h1>推荐</h1><div class=author>ydafu168</div><div class=timestamp>2025-8-8 19:28</div> 感觉好复杂呢？我使用AI编写小程序，直接告诉它加上注册功能，要有机器码，注册码是根据机器码算出来的，然后它就麻溜的听话真的整了个注册功能。 </div><div class=postcontent><h1>推荐</h1><div class=author>hrh123</div><div class=timestamp>2025-8-8 19:52</div><div class=quote><blockquote><font size=2><a href="https://www.52pojie.cn/forum.php?mod=redirect&goto=findpost&pid=53630111&ptid=2052009" target=_blank><font color=#999999>pythonfun 发表于 2025-8-8 19:41</font></a></font><br> 太强了吧，我眼都看花了，不过很实现，我发现有时机器码容易变，然后注册码就变了，很麻烦。</blockquote></div><br> 不同的实现方式会有不同的结果，可能你用的那个程序刚好用了个奇怪的算法，加了个会变的量，机器码就容易变了。 </div><div class=postcontent><h1>3#</h1><div class=author>CreepGF</div><div class=timestamp>2025-8-8 19:28</div> 牛啊牛啊 </div><div class=postcontent><h1>4#</h1><div class=author><a class="xi2 xw1" href="home.php?mod=space&uid=1597267">hrh123</a></div><div class=timestamp>2025-8-8 19:41</div> 太强了吧，我眼都看花了，不过很实现，我发现有时机器码容易变，然后注册码就变了，很麻烦。 <div class=comment-container><div class=comment-header>点评</div><div class=comment-body><div class=comment-author>hrh123</div><div class=comment-text> 不同的实现方式会有不同的结果，可能你用的那个程序刚好用了个奇怪的算法，加了个会变的量，机器码就容易变了。  <a class=xi2 href="forum.php?mod=redirect&goto=findpost&pid=53630150&ptid=2052009">详情</a><a class=xi2 href="forum.php?mod=post&action=reply&fid=24&tid=2052009&repquote=53630150&extra=page%3D1&page=1" onclick="showWindow('reply', this.href)">回复</a></div><div class=comment-time>发表于 2025-8-8 19:52</div></div></div></div><div class=postcontent><h1>5#</h1><div class=author><a class="xi2 xw1" href="home.php?mod=space&uid=1597267">hrh123</a></div><div class=timestamp>2025-8-8 19:42</div> 有注释么？不太好理解 <div class=comment-container><div class=comment-header>点评</div><div class=comment-body><div class=comment-author>hrh123</div><div class=comment-text> ai干这个事很合适，自己去加吧  <a class=xi2 href="forum.php?mod=redirect&goto=findpost&pid=53630162&ptid=2052009">详情</a><a class=xi2 href="forum.php?mod=post&action=reply&fid=24&tid=2052009&repquote=53630162&extra=page%3D1&page=1" onclick="showWindow('reply', this.href)">回复</a></div><div class=comment-time>发表于 2025-8-8 19:54</div></div></div></div><div class=postcontent><h1>6#</h1><div class=author>scbzwv</div><div class=timestamp>2025-8-8 19:45</div> 感谢楼主分享！ </div><div class=postcontent><h1>8#</h1><div class=author>hrh123</div><div class=timestamp>2025-8-8 19:54</div><div class=quote><blockquote><font size=2><a href="https://www.52pojie.cn/forum.php?mod=redirect&goto=findpost&pid=53630118&ptid=2052009" target=_blank><font color=#999999>78zhanghao87 发表于 2025-8-8 19:42</font></a></font><br> 有注释么？不太好理解</blockquote></div><br> ai干这个事很合适，自己去加吧 </div><div class=postcontent><h1>9#</h1><div class=author>wuzhipeng2024</div><div class=timestamp>2025-8-8 20:53</div> 看上去很不错的 </div><div class=postcontent><h1>10#</h1><div class=author>Eaglecad</div><div class=timestamp>2025-8-8 21:06</div> 感谢分享，话说这生成的机器码和注册机的那种机器码是一回事吗 </div></div></body></html>