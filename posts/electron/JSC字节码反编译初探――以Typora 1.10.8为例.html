<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1.0"><title>帖子内容</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>hljs.highlightAll();</script><style>*{word-wrap:break-word}body,html{margin:0;padding:0;width:93%;height:100%}.table-container{width:93vw;overflow-x:auto}table{margin:.25em auto;width:100%;max-width:100%;table-layout:auto;overflow:auto;border-spacing:0;border-collapse:collapse}table tr:nth-child(2n){background-color:#f6f8fa}table thead{background-color:#d9e2df}table th{font-weight:600}table tr{border-top:1px solid #c6cbd1}table td,table th{padding:6px 13px;border:1px solid #c6cbd1 text-align:center}pre{background-color:#F8F8F8;border:1px solid #CCCCCC;border-radius:3px;padding:2px;overflow-x:auto;width:100%;box-sizing:border-box}code{font-family:Consolas,Monaco,Andale Mono,monospace;background-color:#f5f5f5}pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{background:#000;color:#f8f8f8}.hljs-comment,.hljs-meta,.hljs-quote{color:#7c7c7c}.hljs-keyword,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#96cbfe}.hljs-attribute,.hljs-selector-id{color:#ffffb6}.hljs-addition,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string{color:#a8ff60}.hljs-subst{color:#daefa3}.hljs-link,.hljs-regexp{color:#e9c062}.hljs-doctag,.hljs-section,.hljs-title,.hljs-type{color:#ffffb6}.hljs-bullet,.hljs-literal,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#c6c5fe}.hljs-deletion,.hljs-number{color:#ff73fd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.container{width:100%;margin:20px auto;padding:20px;border-radius:8px;word-wrap:break-word}.postcontent{width:100%;margin-bottom:20px;border-bottom:3px solid #e0f7ff;padding-bottom:10px;word-wrap:break-word}.postcontent:last-child{border-bottom:none}.postcontent h1{margin:0 0 10px;font-size:24px}.postcontent p{margin:0 0 10px;font-size:16px}.postcontent .author{font-size:14px;color:#555}.postcontent .timestamp{font-size:12px;color:#888}.postcontent blockquote{border-left:4px solid #ccc;padding:5px 10px;margin:10px 0;background:#f9f9f9}.postcontent blockquote cite{display:block;text-align:right;font-size:12px;color:#555}.postcontent img{max-width:100%;height:auto;margin:10px 0}.postcontent table{width:100%;border-collapse:collapse;margin:10px 0}.postcontent table th,.postcontent table td{border:1px solid #ddd;padding:8px;text-align:left}.postcontent button{background:#007bff;color:#fff;border:none;padding:10px 20px;font-size:16px;cursor:pointer;border-radius:5px}.postcontent button:hover{background:#0056b3}.comment-container{width:90%;margin:20px auto;border:1px solid #f0f0f0;padding:20px;border-radius:5px;font-family:Arial,sans-serif}.comment-header{background-color:#fff7e6;padding:10px;border-left:5px solid #ff5722;margin:-20px -20px 20px;border-radius:5px 5px 0 0;font-weight:bold}.comment-body{margin-top:10px}.comment-author{font-size:18px;color:#333}.comment-text{font-size:16px;color:#555}.comment-time{text-align:right;color:#999;margin-top:10px}</style><div id=zxsq-markdown-code-tools style=display:none;><span class=show>显示代码</span><span class=hide>隐藏代码</span><span class=copy>复制代码</span><span class=copysucc style=display:none>代码已复制到剪贴板</span></div><script>(function(){function n(n,t=1500){var e=document.createElement("div");e.style.position="fixed",e.style.top="20px",e.style.left="50%",e.style.transform="translateX(-50%)",e.style.padding="10px",e.style.backgroundColor="rgba(0, 0, 0, 0.7)",e.style.color="white",e.style.borderRadius="5px",e.style.zIndex="10000",e.innerHTML=n,document.body.appendChild(e),setTimeout(()=>{document.body.removeChild(e)},t)}function t(t,e){var o=document.createElement("textarea");o.value=t,o.style.position="fixed",o.style.opacity="0",document.body.appendChild(o),o.select();try{document.execCommand("copy")&&n(e)}catch(t){console.error("Failed to copy",t)}document.body.removeChild(o)}function e(){var e=document.getElementById("zxsq-markdown-code-tools"),o=e.querySelector(".show").innerText,c=e.querySelector(".hide").innerText,d=e.querySelector(".copy").innerText,i=e.querySelector(".copysucc").innerText;document.querySelectorAll("pre").forEach(e=>{if("hideCode"===e.firstChild.className||"CopyMyCode"===e.firstChild.className||"showCode"===e.firstChild.className)return;var r=document.createElement("div");r.style.display="flex",r.style.justifyContent="flex-start",r.style.alignItems="center",r.style.marginBottom="10px";var a=document.createElement("em");a.className="CopyMyCode",a.style="cursor:pointer;font-size:12px;color:#369 !important;margin-right:10px;",a.innerText=d,r.appendChild(a),a.onclick=function(){t(this.parentElement.parentElement.lastChild.innerText,i)};var s=document.createElement("em");s.className="hideCode",s.style="cursor:pointer;font-size:12px;color:#369 !important;",s.innerText=c,r.appendChild(s),s.onclick=function(){var n=this.parentElement.parentElement.lastChild;"hideCode"===this.className?(n.style.display="none",this.className="showCode",this.innerText=o):(n.style.display="block",this.className="hideCode",this.innerText=c)},e.insertBefore(r,e.firstChild)})}
window.addEventListener("load",e)})();</script></head><body><div class=container><p>原帖地址:https://www.52pojie.cn/thread-2054765-1-1.html</p><div class=postcontent><h1>楼主</h1><div class=author>xqyqx</div><div class=timestamp>2025-8-21 02:11</div><i class=pstatus> 本帖最后由 xqyqx 于 2025-8-21 09:40 编辑 </i><br><h2 id=53710061_jsc字节码反编译初探――以typora-1.10.8为例>JSC字节码反编译初探――以Typora 1.10.8为例</h2><p>在之前的<a href=https://www.52pojie.cn/thread-2040749-1-1.html rel="noopener noreferrer nofollow" target=_blank>文章</a>中，我们已经尝试了通过hook node api的方式替换公钥，这次我们来尝试一下从那个已经被编译为字节码的jsc入手</p><p>在网上搜索jsc反编译相关的内容，找到一篇相关<a href=https://guage.cool/wiz-license.html rel="noopener noreferrer nofollow" target=_blank>教程</a>，作者通过修改d8，添加<code>Disassemble</code>、<code>LoadJSC</code>函数，从而实现解析jsc，我们也依照此思路进行分析</p><h3 id=53710061_制作反编译器>制作反编译器</h3><p>在安装目录下的version文件中可以看到electron 版本为<code>32.1.2</code>，在网上搜索可知对应的v8版本为<code>12.8.374.33</code>，我们先在本地搭建v8编译环境，并<code>git checkout 12.8.374.33</code></p><p>由于自12版本开始，v8引擎做了比较大的api变动，作者原先教程中的修改代码不再适用，下面是我在此基础上做的修正：</p><p>在<code>src/d8/d8.cpp</code>中添加下面两个方法：</p><pre><code class=language-cpp>static void Disassemble(v8::internal::Isolate* isolate, 
                        v8::internal::Tagged&lt;v8::internal::BytecodeArray&gt; bytecode, 
                        std::unordered_set&lt;uintptr_t&gt;&amp; visited,
                        int depth) {
  if (depth &gt; 100) { 
    v8::internal::PrintF("Recursion depth limit reached, aborting disassembly for this path.\n");
    fflush(stdout);
    return;
  }

  uintptr_t key = reinterpret_cast&lt;uintptr_t&gt;(bytecode.ptr());
  if (visited.count(key)) {
    return;
  }
  visited.insert(key);
  for (int i = 0; i &lt; depth; ++i) v8::internal::PrintF("  ");
  v8::internal::PrintF("Disassembling BytecodeArray at: %p\n", reinterpret_cast&lt;void*&gt;(bytecode.ptr()));
  fflush(stdout);
  v8::internal::OFStream os(stdout);
  bytecode-&gt;Disassemble(os);

  auto consts = bytecode-&gt;constant_pool();

  for (int i = 0; i &lt; depth; ++i) v8::internal::PrintF("  ");
  v8::internal::PrintF("Constant pool size: %d\n", consts-&gt;length());
  fflush(stdout);

  for (int i = 0; i &lt; consts-&gt;length(); i++) {
    auto obj = consts-&gt;get(i);
    if (v8::internal::IsSharedFunctionInfo(obj)) {
      auto shared = v8::internal::Cast&lt;v8::internal::SharedFunctionInfo&gt;(obj);

      for (int i = 0; i &lt; depth; ++i) v8::internal::PrintF("  ");
      v8::internal::PrintF("--&gt; Found SFI in constant pool at index %d: ", i);

      auto function_name = shared-&gt;Name();
      if (function_name-&gt;length() &gt; 0) {
          v8::internal::PrintF("%s\n", function_name-&gt;ToCString().get());
      } else {
          v8::internal::PrintF("(anonymous)\n");
      }
      fflush(stdout);

      if (shared-&gt;HasBytecodeArray()) {
          Disassemble(isolate, shared-&gt;GetBytecodeArray(isolate), visited, depth + 1);
      } else {
          for (int i = 0; i &lt; depth; ++i) v8::internal::PrintF("  ");
          v8::internal::PrintF("    (SFI has no bytecode array, skipping)\n");
          fflush(stdout);
      }
    }
  }
}

void v8::Shell::LoadJSC(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args) {
  auto isolate = reinterpret_cast&lt;v8::internal::Isolate*&gt;(args.GetIsolate());
  for (int i = 0; i &lt; args.Length(); i++) {
    v8::String::Utf8Value filename(args.GetIsolate(), args[i]);
    if (*filename == NULL) {
      args.GetIsolate()-&gt;ThrowException(v8::Exception::Error(
          v8::String::NewFromUtf8(args.GetIsolate(), "Error loading file").ToLocalChecked()));
      return;
    }
    int length = 0;
    auto filedata = reinterpret_cast&lt;uint8_t*&gt;(ReadChars(*filename, &amp;length));
    if (filedata == NULL) {
      args.GetIsolate()-&gt;ThrowException(v8::Exception::Error(
          v8::String::NewFromUtf8(args.GetIsolate(), "Error reading file").ToLocalChecked()));
      return;
    }
    v8::internal::AlignedCachedData cached_data(filedata, length);
    auto source = isolate-&gt;factory()
                      -&gt;NewStringFromUtf8(base::CStrVector("source"))
                      .ToHandleChecked();
    v8::internal::ScriptDetails script_details;
    v8::internal::MaybeHandle&lt;v8::internal::SharedFunctionInfo&gt; maybe_fun =
        v8::internal::CodeSerializer::Deserialize(isolate, &amp;cached_data, source, script_details);

    v8::internal::Handle&lt;v8::internal::SharedFunctionInfo&gt; fun;
    if (!maybe_fun.ToHandle(&amp;fun)) {
      args.GetIsolate()-&gt;ThrowException(v8::Exception::Error(
          v8::String::NewFromUtf8(args.GetIsolate(), "Deserialize failed, possibly version mismatch or invalid .jsc file").ToLocalChecked()));
      delete[] filedata;
      return;
    }

    v8::internal::PrintF("---- Starting disassembly of %s ----\n", *filename);
    fflush(stdout);

    std::unordered_set&lt;uintptr_t&gt; visited;
    Disassemble(isolate, fun-&gt;GetBytecodeArray(isolate), visited, 0); 

    v8::internal::PrintF("---- Finished disassembly of %s ----\n", *filename);
    fflush(stdout);

    delete[] filedata;
  }
}</code></pre><p>并在<code>Shell::CreateGlobalTemplate</code>中添加代码：</p><pre><code class=language-cpp>global_template-&gt;Set(
    v8::String::NewFromUtf8(isolate, "loadjsc", v8::NewStringType::kNormal)
        .ToLocalChecked(),
    v8::FunctionTemplate::New(isolate, v8::Shell::LoadJSC));</code></pre><p>在<code>src/d8/d8.h</code>的<code>class Shell</code>中添加<code>LoadJSC</code>声明：</p><pre><code class=language-cpp>static void LoadJSC(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</code></pre><p><code>src/diagnostics/objects-printer.cc</code>:</p><p>注释掉：<code>PrintSourceCode(os);</code></p><p>在</p><pre><code class=language-cpp>  os &lt;&lt; "\n - age: " &lt;&lt; age();
  os &lt;&lt; "\n";</code></pre><p>后添加</p><pre><code class=language-python>  os &lt;&lt; "\nStart BytecodeArray\n";
  this-&gt;GetActiveBytecodeArray(isolate)-&gt;Disassemble(os);
  os &lt;&lt; "\nEnd BytecodeArray\n";</code></pre><p>在</p><pre><code class=language-cpp>void HeapObject::HeapObjectShortPrint(std::ostream&amp; os) {
  PtrComprCageBase cage_base = GetPtrComprCageBase();</code></pre><p>后添加</p><pre><code class=language-cpp>  Isolate* isolate = nullptr;
  if (!GetIsolateFromHeapObject(*this, &amp;isolate) || isolate == nullptr) {
    os &lt;&lt; "[!!! Corrupted HeapObject (cannot get Isolate) at "
       &lt;&lt; reinterpret_cast&lt;void*&gt;(this-&gt;ptr()) &lt;&lt; " !!!]";
    return;
  }
  ReadOnlyRoots roots(isolate);
  Tagged&lt;Map&gt; map_of_this_object = this-&gt;map(cage_base);
  if (map_of_this_object.ptr() == kNullAddress) {
    os &lt;&lt; "[!!! Corrupted HeapObject (null map pointer) at "
       &lt;&lt; reinterpret_cast&lt;void*&gt;(this-&gt;ptr()) &lt;&lt; " !!!]";
    return;
  }
  if (map_of_this_object-&gt;map(cage_base) != roots.meta_map()) {
    os &lt;&lt; "[!!! Corrupted HeapObject (invalid map) at "
       &lt;&lt; reinterpret_cast&lt;void*&gt;(this-&gt;ptr()) &lt;&lt; " !!!]";
    return;
  }
</code></pre><p>在</p><pre><code class=language-cpp>    os &lt;&lt; accumulator.ToCString().get();
    return;
  }
</code></pre><p>后添加</p><pre><code class=language-cpp>  if (map(cage_base)-&gt;instance_type() == ASM_WASM_DATA_TYPE) {
    os &lt;&lt; "&lt;ArrayBoilerplateDescription&gt; ";
    Cast&lt;ArrayBoilerplateDescription&gt;(*this)
        -&gt;constant_elements()
        -&gt;HeapObjectShortPrint(os);
    return;
  }</code></pre><p>在</p><pre><code class=language-cpp>    case FIXED_ARRAY_TYPE:
      os &lt;&lt; "&lt;FixedArray[" &lt;&lt; Cast&lt;FixedArray&gt;(*this)-&gt;length() &lt;&lt; "]&gt;";</code></pre><p>后添加</p><pre><code class=language-cpp>      os &lt;&lt; "\nStart FixedArray\n";
      Cast&lt;FixedArray&gt;(*this)-&gt;FixedArrayPrint(os);
      os &lt;&lt; "\nEnd FixedArray\n";</code></pre><p>在</p><pre><code class=language-cpp>    case OBJECT_BOILERPLATE_DESCRIPTION_TYPE:
      os &lt;&lt; "&lt;ObjectBoilerplateDescription["
         &lt;&lt; Cast&lt;ObjectBoilerplateDescription&gt;(*this)-&gt;capacity() &lt;&lt; "]&gt;";</code></pre><p>后添加</p><pre><code class=language-cpp>      os &lt;&lt; "\nStart ObjectBoilerplateDescription\n";
      Cast&lt;ObjectBoilerplateDescription&gt;(*this)
          -&gt;ObjectBoilerplateDescriptionPrint(os);
      os &lt;&lt; "\nEnd ObjectBoilerplateDescription\n";</code></pre><p>在</p><pre><code class=language-cpp>    case FIXED_DOUBLE_ARRAY_TYPE:
      os &lt;&lt; "&lt;FixedDoubleArray[" &lt;&lt; Cast&lt;FixedDoubleArray&gt;(*this)-&gt;length()
         &lt;&lt; "]&gt;";</code></pre><p>后添加</p><pre><code class=language-cpp>      os &lt;&lt; "\nStart FixedDoubleArray\n";
      Cast&lt;FixedDoubleArray&gt;(*this)-&gt;FixedDoubleArrayPrint(os);
      os &lt;&lt; "\nEnd FixedDoubleArray\n";</code></pre><p>在</p><pre><code class=language-cpp>      } else {
        os &lt;&lt; "&lt;SharedFunctionInfo&gt;";
      }</code></pre><p>后添加</p><pre><code class=language-cpp>      os &lt;&lt; "\nStart SharedFunctionInfo\n";
      shared-&gt;SharedFunctionInfoPrint(os);
      os &lt;&lt; "\nEnd SharedFunctionInfo\n";</code></pre><p><code>src/snapshot/code-serializer.cc</code>：</p><p>替换<code>SanityCheck</code>、<code>SanityCheckWithoutSource</code>函数：</p><pre><code class=language-cpp>SerializedCodeSanityCheckResult SerializedCodeData::SanityCheck(
    uint32_t expected_ro_snapshot_checksum,
    uint32_t expected_source_hash) const {
  return SerializedCodeSanityCheckResult::kSuccess;
}

SerializedCodeSanityCheckResult SerializedCodeData::SanityCheckWithoutSource(
    uint32_t expected_ro_snapshot_checksum) const {
  // Always return kSuccess to bypass all checks.
  return SerializedCodeSanityCheckResult::kSuccess;
}</code></pre><p><code>src/snapshot/deserializer.cc</code>：</p><p>替换<code>ReadReadOnlyHeapRef</code>函数：</p><pre><code class=language-cpp>int Deserializer&lt;IsolateT&gt;::ReadReadOnlyHeapRef(uint8_t data,
                                                SlotAccessor slot_accessor) {
  uint32_t chunk_index = source_.GetUint30();
  uint32_t chunk_offset = source_.GetUint30();

  ReadOnlySpace* read_only_space = isolate()-&gt;heap()-&gt;read_only_space();

  if (chunk_index &gt;= read_only_space-&gt;pages().size()) {
    Tagged&lt;Hole&gt; the_hole = *isolate()-&gt;factory()-&gt;the_hole_value();

    return WriteHeapPointer(slot_accessor, the_hole,
                            GetAndResetNextReferenceDescriptor());
  }

  ReadOnlyPageMetadata* page = read_only_space-&gt;pages()[chunk_index];
  Address address = page-&gt;OffsetToAddress(chunk_offset);
  Tagged&lt;HeapObject&gt; heap_object = HeapObject::FromAddress(address);

  return WriteHeapPointer(slot_accessor, heap_object,
                          GetAndResetNextReferenceDescriptor());
}</code></pre><p>以上为全部修改，之后使用<code>ninja -C out.gn/x64.release d8</code>编译</p><p>编译好后运行<code>./out.gn/x64.release/d8 -e "loadjsc('atom.compiled.dist.jsc')" &gt; atom.txt</code>即可得到反编译后的结果：</p><p><a href=https://wwri.lanzouo.com/iB9Ea34181jc rel="noopener noreferrer nofollow" target=_blank>https://wwri.lanzouo.com/iB9Ea34181jc</a></p><h3 id=53710061_分析atom.txt>分析atom.txt</h3><p>面对海量的字节码，我们直奔主题，寻找rsa公钥，在之前版本的atom.js中，我们可以得知公钥是base64解析出来的：</p><pre><code class=language-javascript>T = JSON.parse(Buffer.from("WyItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLSIsIk1JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0NBUUVBN25Wb0dDSHFJTUp5cWdBTEVVcmMiLCI1SkpoYXAwK0h0SnF6UEUwNHB6NHkrbnJPbVk3LzEyZjNIdlp5eW9Sc3hLZFhUWmJPMHdFSEZJaDBjUnFzdWFKIiwiUHlhT09QYkEwQnNhbG9mSUFZM21SaFFRM3ZTZitybjNnK3cwUyt1ZFdtS1Y5RG5tSmxwV3FpekZhalU0VC9FNCIsIjVaZ01OY1h0M0UxaXBzMzJyZGJUUjBObmVuOVBWSVR2cmJKM2w2Q0kyQkZCSW1aUVoyUDhOK0xzcWZKc3F5VlYiLCJ3RGt0M21IQVZ4VjdGWmJmWVdHKzhGRFN1S1FIYUNtdmdBdENoeDlod2wzSjZSZWtrcURWYTZHSVYxM0QyM0xTIiwicWRrMEpiNTIxd0ZKaS9WNlFBSzZTTEJpYnk1Z1lONnpRUTVSUXBqWHRSNTNNd3pUZGlBekdFdUtkT3RyWTJNZSIsIkR3SURBUUFCIiwiLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tIiwiIiwiIl0=","base64").toString("utf8")).join("\n"),
I = 864e5;
var W = "https://store.typora.io";</code></pre><p>我们直接在反编译结果中搜索这段base64没有搜索到，怀疑是v8对其进行了优化，我们可以通过后面的字符串<code>https://store.typora.io</code>来尝试对这段代码进行定位，在反编译结果中搜索，向上可以找到一个长度为476的数组：</p><pre><code>0x3340001a57f9: [FixedArray] in OldSpace
 - map: [!!! Corrupted HeapObject (cannot get Isolate) at 0x33400000065d !!!]
 - length: 476
           0: 91
           1: 34
         2-6: 45
           7: 66
           8: 69
           9: 71
          10: 73
          11: 78
          12: 32
          13: 80
          14: 85
          15: 66
          16: 76
          17: 73
          18: 67</code></pre><p>将数字转换为ascii，发现是PEM公钥的数组形式</p><p>那我们如何对其进行修改呢？</p><p>注意到这个数组在Constant pool中，也就是储存在堆中的，而不是动态生成，因此我们可以在jsc文件中找到并对其进行修改</p><p>在jsc中我们同样以<code>https://store.typora.io</code>作为锚点进行寻找，发现往上有一个很长的数据块：</p><pre><code>03 00 00 B6 00 00 00 44 00 00 00 5A 00 00 00 5A
00 00 00 5A 00 00 00 5A 00 00 00 5A 00 00 00 84
00 00 00 8A 00 00 00 8E 00 00 00 92 00 00 00 9C
00 00 00 40 00 00 00 A0 00 00 00 AA 00 00 00 84
00 00 00 98 00 00 00 92 00 00 00 86 00 00 00 40
00 00 00 96 00 00 00 8A 00 00 00 B2 00 00 00 5A
00 00 00 5A 00 00 00 5A 00 00 00 5A 00 00 00 5A
00 00 00 44 00 00 00 58 00 00 00 44 00 00 00 9A
00 00 00 92 00 00 00 92 00 00 00 84 00 00 00 92
00 00 00 D4 00 00 00 82 00 00 00 9C 00 00 00 84
......</code></pre><p>这里我们发现了两组5个重复的0x5A，中间夹着16个字节，这恰好与我们先前在Constant pool中找到的数组相对应（两组5个重复的45中间夹着16个数），可以确定这段数据就是公钥</p><p>尝试异或发现不对，于是猜测应该是类似cython一样，每个字符都有对应的标识符（例如这里0x5A对应45），由于原始公钥内有足够多的字符，应该可以生成一个对应表，这样就可以替换公钥了</p><p>关于网验：<br> 可以找到下面一段字节码：</p><pre><code>         0xba50004e020 @   76 : c2                Star8
         0xba50004e021 @   77 : 0d 2f             LdaSmi [47]
         0xba50004e023 @   79 : c0                Star10
         0xba50004e024 @   80 : 0d 61             LdaSmi [97]
         0xba50004e026 @   82 : bf                Star11
         0xba50004e027 @   83 : 0d 70             LdaSmi [112]
         0xba50004e029 @   85 : be                Star12
         0xba50004e02a @   86 : 0d 69             LdaSmi [105]
         0xba50004e02c @   88 : bd                Star13
         0xba50004e02d @   89 : 0d 2f             LdaSmi [47]
         0xba50004e02f @   91 : bc                Star14
         0xba50004e030 @   92 : 0d 63             LdaSmi [99]
         0xba50004e032 @   94 : bb                Star15
         0xba50004e033 @   95 : 0d 6c             LdaSmi [108]
         0xba50004e035 @   97 : 18 e9             Star r16
         0xba50004e037 @   99 : 0d 69             LdaSmi [105]
         0xba50004e039 @  101 : 18 e8             Star r17
         0xba50004e03b @  103 : 0d 65             LdaSmi [101]
         0xba50004e03d @  105 : 18 e7             Star r18
         0xba50004e03f @  107 : 0d 6e             LdaSmi [110]
         0xba50004e041 @  109 : 18 e6             Star r19
         0xba50004e043 @  111 : 0d 74             LdaSmi [116]
         0xba50004e045 @  113 : 18 e5             Star r20
         0xba50004e047 @  115 : 0d 2f             LdaSmi [47]
         0xba50004e049 @  117 : 18 e4             Star r21
         0xba50004e04b @  119 : 0d 72             LdaSmi [114]
         0xba50004e04d @  121 : 18 e3             Star r22
         0xba50004e04f @  123 : 0d 65             LdaSmi [101]
         0xba50004e051 @  125 : 18 e2             Star r23
         0xba50004e053 @  127 : 0d 6e             LdaSmi [110]
         0xba50004e055 @  129 : 18 e1             Star r24
         0xba50004e057 @  131 : 0d 65             LdaSmi [101]
         0xba50004e059 @  133 : 18 e0             Star r25
         0xba50004e05b @  135 : 0d 77             LdaSmi [119]</code></pre><p>对应的字符串为<code>/api/client/renew</code>，作者应该是在js源码中使用<code>charCodeAt</code>防止直接搜字符串被搜到<font color=#000><font face="Consolas, Courier, monospace">，</font></font>用16进制搜索替换掉这些立即数即可</p><div class=parsedown-markdown-end_FLAG_ZXSQ style=display:none></div></div><div class=postcontent><h1>推荐</h1><div class=author>Azuria</div><div class=timestamp>2025-8-21 10:46</div><i class=pstatus> 本帖最后由 Azuria 于 2025-8-21 12:29 编辑 </i><br><blockquote><pre><code>03 00 00 B6 00 00 00 44 00 00 00 5A 00 00 00 5A
00 00 00 5A 00 00 00 5A 00 00 00 5A 00 00 00 84
00 00 00 8A 00 00 00 8E 00 00 00 92 00 00 00 9C
00 00 00 40 00 00 00 A0 00 00 00 AA 00 00 00 84
00 00 00 98 00 00 00 92 00 00 00 86 00 00 00 40
00 00 00 96 00 00 00 8A 00 00 00 B2 00 00 00 5A
00 00 00 5A 00 00 00 5A 00 00 00 5A 00 00 00 5A
00 00 00 44 00 00 00 58 00 00 00 44 00 00 00 9A
00 00 00 92 00 00 00 92 00 00 00 84 00 00 00 92
00 00 00 D4 00 00 00 82 00 00 00 9C 00 00 00 84
......</code></pre><p>这里我们发现了两组5个重复的0x5A，中间夹着16个字节，这恰好与我们先前在Constant pool中找到的数组相对应（两组5个重复的45中间夹着16个数），可以确定这段数据就是公钥</p><p>尝试异或发现不对，于是猜测应该是类似cython一样，每个字符都有对应的标识符（例如这里0x5A对应45），由于原始公钥内有足够多的字符，应该可以生成一个对应表，这样就可以替换公钥了</p></blockquote><p>这里的公钥并没有对齐，数组事实上是从 <code>B6 00 00 00</code> 开始的。</p><p>公钥和用于验证公钥的明文密文都用的v8 smi存储，最低位其实是tag，对于smi来说总是0，如果整数较大的话这里可能会存HeapObject的指针，并将tag置为1。</p><p>misc做的多的话很容易发现字节码里有三个元素大小为dword的smi大数组，仅更改私钥的情况下typora.log可见block type is not 01错误，即解密后数据不满足pkcs1 padding，也就是密钥不对。</p><p>事实上如果仅patch字节码的话需要修改的地方不止是公钥，不过这里不再叙述，毕竟typora开发者换人了。</p><div class=parsedown-markdown-end_FLAG_ZXSQ style=display:none></div></div><div class=postcontent><h1>沙发</h1><div class=author>pangpang12138</div><div class=timestamp>2025-8-21 07:00</div> 感谢楼主的精彩分享，受益匪浅！ </div><div class=postcontent><h1>3#</h1><div class=author>我是不会改名的</div><div class=timestamp>2025-8-21 08:49</div> 应该就是右移 1 位<br> 0xb6&gt;&gt;1     91<br> 0x44&gt;&gt;1     34 </div><div class=postcontent><h1>4#</h1><div class=author>PoJieDaWang123</div><div class=timestamp>2025-8-21 09:21</div> 感谢分享，新的思路<br></div><div class=postcontent><h1>5#</h1><div class=author>sunflash</div><div class=timestamp>2025-8-21 09:37</div> 来了来了，看到Typora必进。感谢楼主，也感谢Typora对技术普及作出的贡献 </div><div class=postcontent><h1>6#</h1><div class=author>fridaynice</div><div class=timestamp>2025-8-21 10:03</div> 学习到了，不过还在理解中，受益匪浅 </div><div class=postcontent><h1>7#</h1><div class=author>iamok</div><div class=timestamp>2025-8-21 10:20</div> 学习v8字节码玩法。。 </div><div class=postcontent><h1>8#</h1><div class=author>dabaistyle</div><div class=timestamp>2025-8-21 10:25</div> 谢谢分享&amp;#128170;&amp;#10024; </div><div class=postcontent><h1>10#</h1><div class=author>nickley</div><div class=timestamp>2025-8-21 11:05</div> 学习了，发现自学还是非常难的 </div></div></body></html>